
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  [{"content":"Markdown here\n","description":"test post","id":0,"section":"hub","tags":null,"title":"May 2019","uri":"https://follang.org/hub/2019_may/"},{"content":"Markdown here\n","description":"test post","id":1,"section":"hub","tags":null,"title":"April 2019","uri":"https://follang.org/hub/2019_april/"},{"content":"Markdown here\n","description":"test post","id":2,"section":"hub","tags":null,"title":"March 2019","uri":"https://follang.org/hub/2019_march/"},{"content":"Markdown here\n","description":"test post","id":3,"section":"hub","tags":null,"title":"February 2019","uri":"https://follang.org/hub/2019_february/"},{"content":"Markdown here\n","description":"test post","id":4,"section":"hub","tags":null,"title":"January 2019","uri":"https://follang.org/hub/2019_january/"},{"content":"Imoprting modules System libraries This is how including other libraries works, for example include fmt module from standard library:\nuse fmt: mod[std] = {fmt}; def main: mod[init] = { fmt::log.warn(\u0026quot;Last warning!...\u0026quot;) } To use only the log namespace of fmt module:\nuse log mod[std] = {fmt::log}; def main: mod[init] = { pro[] main: int = { log.warn(\u0026quot;Last warning!...\u0026quot;) } } But let\u0026rsquo;s say you only wanna use ONLY the warn functionality of log namespace from fmt module:\nuse warn mod[std] = {fmt::log.warn}; def main: mod[init] = { pro[] main: int = { warn(\u0026quot;Last warning!...\u0026quot;) } } Local libraries To include a local package (example, package name bender), then we include the folder where it is, followed by the package name (folder is where files are located, package is the name defned with mod[])\nuse bend: mod[loc] = {../folder/bender}; Then to acces only a namespace:\nuse space: mod[loc] = {../folder/bender::space}; Definig modules Main module Every file in a folder is part of a package, which means everything in the folder that uses the same package name, share the same scope. Two pakages can\u0026rsquo;t exist in same folder.\ndef shko: mod[] = { // implementation } If a package is an executable, it should have pro[] main: int to tell the compiler where to start.\nuse log mod[std] = {fmt::log}; def shko: mod[] = { pro[] main: int = { log.warn(\u0026quot;Last warning!...\u0026quot;) } } To save the fingers and some brackets, we use a short hand of package declaration at the very top of the page (like golang):\ndef shko: mod[] use log mod[std] = {fmt::log}; pro[] main: int { log.warn(\u0026quot;Last warning!...\u0026quot;) } Namespaces A namespace can be defined in three ways:\n in a subfolder same folder, but in a new file or the same file  and is done by using slash when outside the main module\ndef shko/other: mod[] = { pro[] main: int = { // implementation } // implementation } or in the same module file:\ndef shko: mod[] = { pro[] main: int = { // implementation } def shko/other: mod[] = { // implementation } } Scopes Every file in a folder is part of one package, thus they share the same scope. Thus two varibles with same name at global scope cant be defined. However, this is kind of special for functions. Functions of the same name and same amount of parameters (so identical functions, not function overloading) can be defined in two different files. When called, the one on the same file is used.\nIn case a function exists in two files and is called from thrid one, then this can be resolved in two ways. First when the package is defined, the priority shoud be defined too like: def shko: mod[pri=5], this a function with same name, in a different file, with def shko: mod[pri=4] would be called before. If no proorities are defined, then the function in files with name of the files as priority. So the function add() in \u0026ldquo;file1.shko\u0026rdquo; would be called before \u0026ldquo;file2.shko\u0026rdquo;.\nfile1.fol\nuse log mod[std] = {fmt::log}; def shko: mod[] = { var globalVar = 5 // first instance of a constant $globalVar variable pro[] main: int { log.info( add(5,6) ) // calling function in different file but same package (shko) log.info( sub(8,3) ) // this function is from the same file and not form file2 } fun sub(a, b: int): int = { return .sub(a, b) } } file2.fol\nuse log mod[std] = {fmt::log}; def shko: mod[] = { var globalVar = 5 // this throws an error, as it was declared before fun add(a, b: int): int = { return .add(a, b) } fun sub(a, b: int): int = { // this does not throw error, even another function has the name return .sub(a, b) } } file3.fol\nuse log mod[std] = {fmt::log}; def shko: mod[] = { fun add(a, b: int): int = { return .add(a, b) } } Blocks of code Block statement is used for scopes where members get destroyed when scope is finished. And there are two ways to define a block: unnamed blocks and named blocks\nUnnamed blocks Are simply scopes, that may or may not return value, and are represented as: { //block }\ndef shko: mod[] = { pro[] main: int = { { .echo(\u0026quot;simple type block\u0026quot;) } .echo({ return \u0026quot;return type block\u0026quot; }) } } If the block is prepended with a dot in front like: .{ //block } then, when block is isolated on runtime too, in case of error, will not exit the program. it is meant for testing only\ndef shko: mod[] = { var const: int = 5 pro[] main: int = { .{ const = 6; // this throws an error, but the program doen't exit } .echo(const) // this still returns the value 5 } } Named blocks Blocks can be used as labels too, when we want to unconditionally jump to a specific part of the code.\ndef shko/other: mod[] = { pro[] main: int = { def block: blk[] = { // $block A named block that can be referenced // implementation } def mark: blk[] // $mark A named block that can be referenced, usually for \u0026quot;jump\u0026quot; statements } } Unit tests Blocks defined with type tst, have access to the module (or namespace) defined in tst[\u0026quot;name\u0026quot;, access].\ndef test1: tst[\u0026quot;sometest\u0026quot;, shko] = {} def \u0026quot;some unit testing\u0026quot;: tst[shko] = {} ","description":"","id":14,"section":"docs","tags":null,"title":"Modules","uri":"https://follang.org/docs/spec/modules/"},{"content":"Build-in functions Fol has some build-in functions offered by compiler, and you access them by . (with space/newline/bracket before):\nvar contPoint: ptr[int] = 10;\t// make a pointer and asign the memory to value of 10 .print(.pointer_value(contPoint));\t// print the dereferenced value of pointer Macro system are a very complicated system, and yet can be used as simply as in-place replacement. A lot of build-in macros exist in the language to make the code more easy to type. Below are some system defined macros.\nFor example, wherever $ is before any variable name, its replaced with .to_string. Or wherever ! is before bol name, its replaced with .not but when the same ! is placed before ptr it is replaced with .delete_pointer.\ndef '$'(a: any): mac = '.to_string' def '!'(a: bol): mac = '.not ' def '!'(a: ptr): mac = '.delete_pointer'; def '*'(a: ptr): mac = '.pointer_value'; def '#'(a: any): mac = '.borrow_from'; def '\u0026amp;'(a: any): mac = '.address_of'; Alternatives Alternatives are used when we want to simplify code. For example, define an alternative, so whenever you write +var it is the same as var[+].\ndef '+var': alt = 'var[+]' def '~var': alt = 'var[~]' def '.pointer_content': alt = '.pointer_value' Defaults Defaults are a way to change the default behaviour of options. Example the default behaviour of str when called without options. By defalt str is it is saved on stack, it is a constant and not public, thus has str[pil,imu,nor], and we want to make it mutable and saved on heap by default:\ndef 'str': def[] = 'str[new,mut,nor]' Templates Templates are supposed to be mostly used for operator overloading. They are glorified functions, hence used with pro or fun instead of def.\nFor example here is how the != is defined:\nfun '!='(a, b: int): bol = { return .not(.eq(a, b)) } .assert( 5 != 4 ) or define $ to return the string version of an object (careful, it is object$ and not $object, the latest is a macro, not a template):\npro (file)'$': str = { return \u0026quot;somestring\u0026quot; } .echo( file$ ) WITH ALTERNATIVES, MACROS AND TEMPLATES, YOU CAN COMPLETELY MAKE A NEW TYPESYSTEM, WITH ITS OWN KEWORSD AND BEHAVIOUR. HOWEVER, THIS IS NOT SUGGESTED, RELAYING HEAVILY ON IT, THE CODE MIGHT LOOSES THE READABILITY WHEN SOMEONE ELSE WANTS TO USE.\n","description":"","id":16,"section":"docs","tags":null,"title":"Behaviour","uri":"https://follang.org/docs/spec/behaviour/"},{"content":"Statements and expressions ","description":"","id":18,"section":"docs","tags":null,"title":"Control","uri":"https://follang.org/docs/spec/control/"},{"content":"Every value in Fol is of a certain data type, which tells Fol what kind of data is being specified so it knows how to work with that data. There are four main subsets: simple, container, complex and special.\nSimple Simple types are the most primitive type of data:\nint[options], flt[options], chr[options], bol Intiger type An integer is a number without a fractional component. We used one integer of the u32 type, the type declaration indicates that the value it’s associated with should be an unsigned integer (signed integer types start with i, instead of u) that takes up 32 bits of space:\nvar aVar: int[u32] = 45; Each variant can be either signed or unsigned and has an explicit size. Signed and unsigned refer to whether it’s possible for the number to be negative or positive—in other words, whether the number needs to have a sign with it (signed) or whether it will only ever be positive and can therefore be represented without a sign (unsigned). It’s like writing numbers on paper: when the sign matters, a number is shown with a plus sign or a minus sign; however, when it’s safe to assume the number is positive, it’s shown with no sign.\nLength | Signed | Unsigned | ----------------------------------- 8-bit | 8 | u8 | 16-bit | 16 |\tu16 | 32-bit\t| 32 |\tu32 | 64-bit\t| 64\t| u64 | 128-bit\t| 128 |\tu128 | arch\t| arch |\tuarch | Float type Fol also has two primitive types for floating-point numbers, which are numbers with decimal points. Fol’s floating-point types are flt[32] and flt[64], which are 32 bits and 64 bits in size, respectively. The default type is flt[64] because on modern CPUs it’s roughly the same speed as flt[32] but is capable of more precision.\nLength | Type | -------------------- 32-bit\t| 32 | 64-bit\t| 64 | arch\t| arch | Floating-point numbers are represented according to the IEEE-754 standard. The flt[32] type is a single-precision float, and flt[f64] has double precision.\npro[] main: int = { var aVar: flt = 2.; // float 64 bit var bVar: flt[64] = .3; // float 64 bit .assert(.sizeof(aVar) == .sizeof(bVar)) // this will true var bVar: flt[32] = .54; // float 32 bit } Character type In The Unicode Standard 8.0, Section 4.5 \u0026ldquo;General Category\u0026rdquo; defines a set of character categories. Fol treats all characters in any of the letter as Unicode letters, and those in the Number category as Unicode digits.\nchr[utf8,utf16,utf32] def testChars: tst[\u0026quot;some testing on chars\u0026quot;] = { var bytes = \u0026quot;hello\u0026quot;; .assert(.typeof(bytes) == *var [5:0]u8); .assert(bytes.len == 5); .assert(bytes[1] == 'e'); .assert(bytes[5] == 0); .assert('e' == '\\x65'); .assert('\\u{1f4a9}' == 128169); .assert('💯' == 128175); .assert(.mem.eql(u8, \u0026quot;hello\u0026quot;, \u0026quot;h\\x65llo\u0026quot;)); } Boolean type The boolean type is named bol in Fol and can be one of the two pre-defined values true and false.\nbol Containers Containers re compound types. They contain other primitive types. To access the types in container those brackets are used: [], so:\nvar container: type = { element, element, element } // declaring a container var varable: type = container[2] // accessing the last element Containers are always zero indexed Arrays arr[type,size] Arrays are the most simple type of container. They contain homogeneous type, meaning that each element in the array has the same type. Arrays always have a fixed length specified as a constant expression arr[type, size]. They can be indexed by any ordinal type to acces its members.\npro[] main: int = { var anArray: arr[int, 5] = { 0, 1, 2, 3, 4 }; // declare an array of intigers of five elements var element = anArray[3]; // accessing the element .echo(element) // prints: 3 } Sets set[type,type,type..] A set is a general way of grouping together a number of values with a variety of types into one compound type. Sets have a fixed length: once declared, they cannot grow or shrink in size. In other programming languages they usually are referenced as tuples.\npro[] main: int = { var aSet: set[str, flt, arr[int, 2]] = { \u0026quot;go\u0026quot;, .3, { 0, 5, 3 } }; var element = aSet[2][1]; // accessing the [1] element of the `arr` in the set .echo(element) // prints: 5 } Sequences seq[type] Sequences are similar to arrays but of dynamic length which may change during runtime (like strings). Sequences are implemented as growable arrays, allocating pieces of memory as items are added. A sequence s is always indexed by integers from 0 to .len(s)-1 and its bounds are checked.\npro[] main: int = { var aSequence: arr[str] = { \u0026quot;get\u0026quot;, \u0026quot;over\u0026quot;, \u0026quot;it\u0026quot; }; // declare an array of intigers of five elements aSequence.add(\u0026quot;pal!\u0026quot;) var element = aSequence[3]; // accessing the element .echo(element) // prints: pal! } The lower bound of an array or sequence may be received by the built-in .low(), the higher bound by .high(). The length may be received by .len().\nSequences are a growable arrays, thus if not allocated in heap but in stack, the size will be defined automatically in compile time and will be changet to static containers (array) To allocate memory on heap, the var[new] is used more about memory, ownreship and pointer :\npro[] main: int = { var[new] aSequence: arr[str] = { \u0026quot;get\u0026quot;, \u0026quot;over\u0026quot;, \u0026quot;it\u0026quot; }; // this sequence is stored in stack } Maps map[key,value] A map is an unordered group of elements of one type, called the element type, indexed by a set of unique keys of another type, called the key type.\npro[] main: int = { var aMap: map[str, int] = { { \u0026quot;US\u0026quot;, 45 }, { \u0026quot;DE\u0026quot;, 82 }, { \u0026quot;AL\u0026quot;, 54 } }; var element = aMap[\u0026quot;US\u0026quot;]; // accessing the \u0026quot;US\u0026quot; key .echo(element) // prints: 45 } The number of map elements is called its length. For a map aMap, it can be discovered using the built-in function .len and may change during execution To add a new element, we use add function:\n.echo(.len(aMap)) // prints: 3 aMap.add({ \u0026quot;IT\u0026quot;, 55 }) .echo(.len(aMap)) // prints: 4 The comparison operators == and != must be fully defined for operands of the key type; thus the key type must not be a function, map, or sequence.\nMaps are a growable containers too, thus if not allocated in heap but in stack, the size will be defined automatically in compile time and will be changet to static containers Any any[] Matrix Matrixes are of type SIMD (single instruction, multiple data )\nmat[sizex] mat[sizex,sizey] mat[sizex,sizey,sizez] Complex there are two complex types:\nnum[arch,64,128] str[8,16,32] Numbers Numbers are complex too and are made of intiger part, sign part, and float part, for example a number -23.44 is made of negative=true, int=24 and flt=0,44. By default has is made by default \u0026ldquo;architecture size\u0026rdquo; types, on 64bit:\n num is similar to set[bol,int[arch],flt[arch]]  Strings Strings are a complex type that are made of array of chars with null terminator \u0026lsquo;\\0\u0026rsquo;, and by default is utf8 encoded:\n str is similar to set[seq[char[utf8]],'\\0']  Special ptr[basetype] err[basetype] non nod ","description":"","id":20,"section":"docs","tags":null,"title":"Types","uri":"https://follang.org/docs/spec/types/"},{"content":"Here are some of the ways that variables can be defined:\nvar[pub,mut] somename: num[i32] = 98; var[pub,exp] snotherone: str = \u0026quot;this is a string\u0026quot; var[~] yetanother = 192.56 var[+] shortlet = true var anarray: arr[str,3] = { \u0026quot;one\u0026quot;, \u0026quot;two\u0026quot;, \u0026quot;three\u0026quot; } var asequence : seq[num[i8]] = { 20, 25, 45, 68, 73,98 } var multiholder: set[num, str] = { 12, \u0026quot;word\u0026quot; } var anothermulti: set[str, seq[num[f32]]] = { \u0026quot;string\u0026quot;, {5.5, 4.3, 7, .5, 3.2} } var shortvar = anothermulti[1][3] var anymulti: any = {5, 10, \u0026quot;string\u0026quot;, {'a',\u0026quot;word\u0026quot;,{{0, \u0026quot;val\u0026quot;},{1, \u0026quot;nal\u0026quot;}}}, false} var getSomeVal = anymulti[3][2][0][0] | \u0026lt; 15 | shortvar Assignments Following the general rule of FOL:\ndeclaration[options] name: type[options] = { implementation; }; then declaring a new variable is like this:\nvar[pub] aVar: int[32] = 64 however, the short version can be used too, and the compiler figures out at compute time the type:\nvar shortVar = 24; // compiler gives this value of `int[arch]` When new variable is created, and uses an old variable to assign, the value is cloned, not referenced:\npro[] main: int = { var aVar: int = 55; var newVar: int = aVar; .assert(\u0026amp;aVar == \u0026amp;newVar) // this will return false } Two variables can not have the same memory location, unless we either borrow, or use pointers.\nVariables can be assigned to an output of a function:\npro[] main: int = { fun addFunc(x, y: int): int = { return x + y; } var aVar: int = addFunc(4, 5); } Piping / Ternary Piping can be used as ternary operator. More about piping can be found here. Here is an example, the code below basically says: if the function internally had an error, don\u0026rsquo;t exit the program, but assign another value (or default value) to the variable:\npro[] main: int = { fun addFunc(x, y: int): int = { return x + y; } var aVar: int = addFunc(4, 5) | result \u0026gt; 8 | return 6; } Borrowing If we want to reference a variable, the easiest way is to borrow the variable, use inside another scope (or the same) and return it back. If the ownership is not returned manually, by the end of the scope, it gets returned automatically.\npro[] main: int = { var[~] aVar: int = 55; { var[bor] newVar: int = aVar // var[bor] represents borrowing .echo(newVar) // this return 55 } .echo(aVar) // here $aVar it not accesible, as the ownership returns at the end of the scope .echo(newVar) // we cant access the variable because the scope has ended } More on borrowing you can find here\nOptions As with all other blocks, var have their options: var[opt]:\nOptions can be of two types:\n flags eg. var[mut] values eg. var[pri=2]  Flag options can have symbol aliases eg. var[mut] is the somename as var[~].\n| opt | s | type | description | control | ---------------------------------------------------------------------------------------------- | mut | ~ | flag | making a variable mutable | mutability | | imu | | flag | making a variable imutable (default) | | | sta | ! | flag | making a variable a static | | ---------------------------------------------------------------------------------------------- | exp | + | flag | making a global variable pubic | visibility | | nor | | flag | making a global variable normal (default) | | | hid | - | flag | making a global variable hidden | | Alternatives There is a shorter way for variables using alternatives, for example, instead of using var[+], a leaner +var can be used instead.\ndef shko: mod[] = { +var aVar: int = 55; pro[] main: int { .echo(aVar) } } However, when we use two option in varable, only one can use the alternative form, so instead of using var[mut,exp], this can be used +var[mut] or +var[~], or vice varsa ~var[exp] or ~var[+]:\ndef shko: mod[] = { +var[mut] aVar: int = 55; pro[] main: int { .echo(aVar) } } Types Immutable types (constants) By default when a variable is defined without options, it is immutable type, for example here an intiger variable:\npro[] main: int = { var aNumber: int = 5; aNumber = 54; // reassigning varibale $aNumber thorws an error } Mutable types If we want a variable to be mutable, we have to explicitly pass as an option to the variable var[mut] or var[~]:\npro[] main: int = { var[mut] aNumber: int = 5 var[~] anotherNumber: int = 24 aNumber, anotherNumber = 6 // this is completely fine, we assign two wariables new values } Static types Is a variable which allows a value to be retained from one call of the function to another, meaning that its lifetime declaration. and can be used as var[sta] or var[!]. This variable is special, because if it is initialized, it is placed in the data segment (aka: initialized data) of the program memory. If the variable is not set, it is places in .bss segmant (aka: uninitialized data)\npro[] main: int = { { var[!] aNumber: int = 5 } { .echo(aNumber) // it works as it is a static variable. } } Scope As disscussed before, files with same name share the same functions and global variables. However, those variables and functions can\u0026rsquo;t be accesed if the whole module is imported in another project. In order for a variable to be accest by the importer, it needs to be have the exp flag option, so var[exp], or var[+]\nmodule shko, file1.fol\ndef shko: mod[] = { fun[+] add(a, b: int) = { return a + b } fun sub(a, b: int) = { return a - b } } module vij, file1.fol\nuse shko: mod[loc] = {../folder/shko} def vij: mod[] = { pro[] main: int { .echo(add( 5, 4 )) // this works perfectly fine, we use a public/exported function .echo(sub( 5, 4 )) // this throws an error, we are trying use a function that is not visible to other libraries } } There is even the opposite option too. If we want a function/variable to be only used inside the file ( so same package but only for that file ) then we use hid option flag: var[hid] or var[-]\nfile1.fol\ndef shko: mod[] = { var[-] aVar: str = \u0026quot;yo, sup!\u0026quot; } file2.fol\ndef shko: mod[] = { pro[] main: int { .echo(aVar) } // this will thro an error (cos $aVar is declared private/hidden) } Multiple Many to many Many variables can be assigned at once, This is especially usefull, if variables have same options but different types eg. variable is mutabe and exported:\n~var[exp] oneVar: int[32] = 24, twoVar = 13, threeVar: string = \u0026quot;shko\u0026quot;; Or to assign multiple variables of the same type:\n~var[exp] oneVar, twoVar: int[32] = 24, 13; To assign multiple variables of multiple types, the type is omitted, however, this way we can not put options on the type (obviously, the default type is assign by compiler):\n~var[exp] oneVar, twoVar, threeVar = 24, 13, \u0026quot;shko\u0026quot;; Another \u0026ldquo;shameless plagiarism\u0026rdquo; from golang can be used by using ( ... ) to group variables:\n~var[exp] ( oneVar: int[32] = 13, twoVar: int[8] = 13, threeVar: str = \u0026quot;shko\u0026quot;, ) Many to one Many variables of the same type can be assigned to one output too:\nvar oneVar, twoVar: int[8] = 2; However, each of them gets a copy of the variable on a new memory address:\n.assert(\u0026amp;oneVar == \u0026amp;twoVar) // this will return false One to many And lastly, one variable can be assigned to multiple ones. This by using container types:\noneVar grouppy: seq[int] = { 5, 2, 4, 6 } Or a more complicated one:\nvar anothermulti: set[str, seq[num[f32]]] = { \u0026quot;string\u0026quot;, {5.5, 4.3, 7, .5, 3.2} } Or a very simple one:\nvar simplemulti: any = { 5, 6, {\u0026quot;go\u0026quot;, \u0026quot;go\u0026quot;, \u0026quot;go\u0026quot;} } Containers Containers are of special type, they hold other types within. As described before, there are few of them\nAccess To acces container variables, brackets like this [] are use:\nvar shortvar = anothermulti[1][3] // compiler will copy the value `anothermulti[1][3]` (which is a float) to a new memory location ","description":"","id":24,"section":"docs","tags":null,"title":"Variables","uri":"https://follang.org/docs/spec/variables/"},{"content":"Stack vs Heap The Stack What is the stack? It\u0026rsquo;s a special region of your computer\u0026rsquo;s memory that stores temporary variables created by each function (including the main() function). The stack is a \u0026ldquo;LIFO\u0026rdquo; (last in, first out) data structure, that is managed and optimized by the CPU quite closely. Every time a function declares a new variable, it is \u0026ldquo;pushed\u0026rdquo; onto the stack. Then every time a function exits, all of the variables pushed onto the stack by that function, are freed (that is to say, they are deleted). Once a stack variable is freed, that region of memory becomes available for other stack variables.\nThe advantage of using the stack to store variables, is that memory is managed for you. You don\u0026rsquo;t have to allocate memory by hand, or free it once you don\u0026rsquo;t need it any more. What\u0026rsquo;s more, because the CPU organizes stack memory so efficiently, reading from and writing to stack variables is very fast.\nA key to understanding the stack is the notion that when a function exits, all of its variables are popped off of the stack (and hence lost forever). Thus stack variables are local in nature. This is related to a concept we saw earlier known as variable scope, or local vs global variables. A common bug is attempting to access a variable that was created on the stack inside some function, from a place in your program outside of that function (i.e. after that function has exited).\nAnother feature of the stack to keep in mind, is that there is a limit (varies with OS) on the size of variables that can be stored on the stack. This is not the case for variables allocated on the heap.\n very fast access don\u0026rsquo;t have to explicitly deallocate variables space is managed efficiently by CPU (memory will not become fragmented) local variables only limit on stack size (OS-dependent) variables cannot be resized  The Heap The heap is a region of your computer\u0026rsquo;s memory that is not managed automatically for you, and is not as tightly managed by the CPU. It is a more free-floating region of memory (and is larger). To allocate memory on the heap, you must use var[new]. Once you have allocated memory on the heap, you are responsible to deallocate that memory once you don\u0026rsquo;t need it any more. If you fail to do this, your program will have what is known as a memory leak. That is, memory on the heap will still be set aside (and won\u0026rsquo;t be available to other processes).\nUnlike the stack, the heap does not have size restrictions on variable size (apart from the obvious physical limitations of your computer). Heap memory is slightly slower to be read from and written to, because one has to use pointers to access memory on the heap. Unlike the stack, variables created on the heap are accessible by any function, anywhere in your program. Heap variables are essentially global in scope.\nElement of the heap have no dependencies with each other and can always be accessed randomly at any time. You can allocate a block at any time and free it at any time. This makes it much more complex to keep track of which parts of the heap are allocated or free at any given time.\n variables can be accessed globally no limit on memory size slower access no guaranteed efficient use of space, memory may become fragmented over time as blocks of memory are allocated, then freed you must manage memory (you\u0026rsquo;re in charge of allocating and freeing variables) variables can be resized anytime  Multithread In a multi-threaded situation each thread will have its own completely independent stack but they will share the heap. Stack is thread specific and Heap is application specific. The stack is important to consider in exception handling and thread executions.\nMemory and Allocation In the case of a normal variable, we know the contents at compile time, so the value is hardcoded directly into the final executable. This is why they are fast and efficient. But these properties only come from the variable immutability. Unfortunately, we can’t put a blob of memory into the binary for each piece of variable whose size is unknown at compile time and whose size might change while running the program.\nLets take an example, the user input as str (string), in order to support a mutable, growable piece of variable, we need to allocate an amount of memory on the heap, unknown at compile time, to hold the contents. This means:\n The memory must be requested from the operating system at runtime. We need a way of returning this memory to the operating system when we’re done with our String.  That first part is done by us: when we call var[new], its implementation requests the memory it needs. This is pretty much universal in any programming languages.\nHowever, the second part is different. In languages with a garbage collector (GC), the GC keeps track and cleans up memory that isn’t being used anymore, and we don’t need to think about it. Without a GC, it’s our responsibility to identify when memory is no longer being used and call code to explicitly return it, just as we did to request it. Doing this correctly has historically been a difficult programming problem. If we forget, we’ll waste memory. If we do it too early, we’ll have an invalid variable. If we do it twice, that’s a bug too. We need to pair exactly one allocate with exactly one free.\nFol, copies Rust in this aspect: the memory is automatically returned once the variable that owns it goes out of scope.\nWhen a variable goes out of scope, Fol calls a special function for us to deallocate all the new memories we have allocated during this dunction call.  This function is called .de_alloc() - just like Rust\u0026rsquo;s drop(), and it’s where the author of var[new] can put the code to return the memory. Fol calls .de_alloc() automatically at the closing curly bracket.\nVariables Much like C++ and Rust, in Fol every variable declared, by default is created in stack unless explicitly specified othervise. Using option [new] or [@] in a variable, it allocates memory in the heap. The size of the allocation is defined by the type. Internally this creates a pointer to heap address, and dereferences it to the type you are having. Usually those behind the scene pointers here are unique pointers. This means that when the scope ends, the memory that the pointer used is freed.\nvar[new] intOnHeap: int[64]; @var intOnHeap: int[64]; Assignments As discussed before, declaring a new variable is like this:\nvar[pub] aVar: int[32] = 64 However, when new variable is created and uses an old variable as value, the value is always cloned for \"stack\" declared values, but moved for \"heap\" declared values.  @var aVar: int[32] = 64 { var bVar = aVar // this moves the content from $aVar to $bVar } .echo(aVar) // this will throw n error, since the $aVar is not anymore owner of any value When the variable is moved, the owner is changed. In example above, the value 64 (saved in stack) is owned my aVar and then the ownership is moved to bVar. Now bVar is the new owner of the variable, making the aVar useless and can\u0026rsquo;t be refered anymore. Since the bVar now controls the value, it\u0026rsquo;s lifetime lasts until the end of the scope. When the scope ends, the variable is destroyed with .de_alloc() function. This because when the ovnership is moved, the attributes are moved too, so the @ of aVar is now part of the bVar even if not implicitly specified. To avoid destruction, the bVar needs to return the ownership back to aVar before the scope ends with .give_back(bVar) or !bVar.\n@var aVar: int[32] = 64 { var bVar = aVar // this moves the content from $aVar to $bVar !bvar // return ownership } .echo(aVar) // this now will print 64 This can be done automatically by using borrowing.\nBorrowing Borrowing does as the name says, it borrows a value from another variable, and at the end of the scope it automatically returns to the owner.\npro[] main: int = { var[~] aVar: int = 55; { var[bor] newVar: int = aVar // represents borrowing .echo(newVar) // this return 55 } .echo(aVar) // here $aVar it not accesible, as the ownership returns at the end of the scope .echo(newVar) // we cant access the variable because the scope has ended } Borrowing uses a predefined option [bor], which is not conventional like other languages that use \u0026amp; or *. This because you can get away just with \u0026ldquo;borrowing\u0026rdquo; without using pointers (so, symbols like * and \u0026amp; are strictly related to pointers)\nHowever, while the value is being borrowed, we can\u0026rsquo;t use the old variable while is being borrowed but we still can lend to another variable:\npro[] main: int = { var[~] aVar: int = 55; { var[bor] newVar = aVar // represents borrowing .echo(newVar) // this prints 55 .echo(aVar) // this throws an error, cos we already have borrowd the value from $aVar var[bor] anotherVar = aVar // $anotherVar again borrows from a $aVar } } When borrowed, a the value is read-only (it's immutable). To make it muttable, firtsly, the owner needs to be muttable, secondly the borrower needs to declarare that it intends to change.  To do so, the borrower uses var[mut, bor]. However, when the value is declared mutable by owner, only one borrower within one scope can declare to modify it:\npro[] main: int = { var[~] aVar: int = 55; { var[mut, bor] newVar = aVar // [mut, bor] represents a mutable borrowing var[mut, bor] anotherVar = aVar // this throws an error, cos we already have borrowed the muttable value before } { var[mut, bor] anotherVar = aVar // this is okay, s it is in another scope } } Pointers The only way to access the same memory with different variable is by using pointers. In example below, we create a pointer, and when we want to dereference it to modify the content of the address that the pointer is pointing to, we use *ptrname or .pointer_value(ptrname).\n@var aContainer: arr[int, 5]; //allocating memory on the heap var contPoint: ptr[] = aContainer; *contPoint = { zero, one, two, three, four }; //dereferencing and then assigning values Bare in mind, that the pointer (so, the address itself) can\u0026rsquo;t be changes, unless when created is marked as var[mut]. To see tha address of a pointer we use \u0026amp;ptrname or .address_of(ptrname)\n@var aContainer: arr[int, 5]; //allocating memory on the heap var contPoint: ptr[] = aContainer; var anotherPoint: ptr[] = \u0026amp;contPoint; //assigning the same adress to another pointer Unique pointer Ponter of a pointer is very simimilar to RUST move pointer, it actually, deletes the first pointer and references the new one to the location of deleted one. However this works only when the pointer is unique (all pointers by default all unique). This is like borrowing, but does not invalidate the source variable:\nvar aContainer: arr[int, 5] = { zero, one, two, three, four }; var contPoint: ptr[] = aContainer; var anotherPoint: ptr[] = \u0026amp;contPoint; with borrowing, we use #varname or .borrow_from(varname)\nvar aContainer: arr[int, 5] = { zero, one, two, three, four }; { var borrowVar = #aContainer; //this makes a new var form the old var, but makes the old invalid (until out of scope) } Shred pointer Ponter can be shared too. They can get referenced by another pointer, and they don\u0026rsquo;t get destroyed until the last reference\u0026rsquo;s scope is finished. This is exacly like smart shared_ptr in C++. Pointer to this pointer makes a reference not a copy as unique pointers. Dereferencing is a bit complicated here, as when you dereference a pointer pointer you get a pointer, so you need to dereference it too to get the value.\n@var aContainer: arr[int, 5] = { zero, one, two, three, four }; var contPoint: ptr[] = aContainer; var pointerPoint: ptr[shared] = \u0026amp;contPoint; Dereferencing (step-by-step):\nvar apointerValue = *pointerPoint var lastpointerValue = *apointer Dereferencing (all-in-one):\nvar lastpointer = *(*pointerPoint) Raw pointer Lastly, pointers can be raw too. This is the base of ALL POINTERS AND VARIABLES. Pointers of this type need to MANUALLY GET DELETED. If a pointer gets deleted before the new pointer that points at it, we get can get memory corruptions:\nvar aContainer: arr[int, 5] = { zero, one, two, three, four }; var contPoint: ptr[raw] = aContainer; var pointerPoint: ptr[raw] = \u0026amp;contPoint; Deleting:\n!(pointerPoint) !(contPoint) ","description":"","id":26,"section":"docs","tags":null,"title":"Ownership","uri":"https://follang.org/docs/spec/pointers/"},{"content":"A subprogram definition describes the interface to and the actions of the subprogram abstraction. A subprogram call is the explicit request that a specific subprogram be executed. A subprogram is said to be active if, after having been called, it has begun execution but has not yet completed that execution.A subprogram declaration consists of an identifier, zero or more argument parameters, a return value type and a block of code.\nfun[] add(el1, el2: int[64]): int[64] = { result = el1 + el2 } You’ve already seen one of the most important subprogram in the language: the main function, which is the entry point of many programs. You’ve also seen the fun or pro keyword, which allows you to declare new subprograms.\nTypes There are two main types of subprograms in fol:\n  Procedurues\nA procedure is a piece of code that is called by name. It can be passed data to operate on (i.e. the parameters) and can optionally return data (the return value). All data that is passed to a procedure is explicitly passed.\n  Functions\nA function is called pure function if it always returns the same result for same argument values and it has no side effects like modifying an argument (or global variable) or outputting to I/O. The only result of calling a pure function is the return value.\n  Parameters Formal parameters Subprogram typically describe computations. There are two ways that a subprogram can gain access to the data that it is to process: through direct access to nonlocal variables (declared elsewhere but visible in the subprogram) or through parameter passing. Data passed through parameters are accessed using names that are local to the subprogram. Subprogram create their own unnamed namespace. Every subprogram has its own Workspace. This means that every variable inside the subprogram is only usable during the execution of the subprogram (and then the variables go away).\nParameter passing is more flexible than direct access to nonlocal variables. Prrameters are special variables that are part of a subprogram’s signature. When a subprogram has parameters, you can provide it with concrete values for those parameters. The parameters in the subprogram header are called formal parameters. They are sometimes thought of as dummy variables because they are not variables in the usual sense: In most cases, they are bound to storage only when the subprogram is called, and that binding is often through some other program variables.\nParameters are declared as a list of identifiers separated by semicolon (or by a colon, but for code cleanness, the semicolon is preferred). A parameter is given a type by : typename. If after the parameter the : is not declared, but , colon to identfy another paremeter, of which both parameters are of the same type if after the second one the : and the type is placed. Then the same type parameters continue to grow with , until : is reached.\nfun[] calc(el1, el2, el3: int[64]; changed: bol = true): int[64] = { result = el1 + el2 - el3 } In subprogram signatures, you must declare the type of each parameter. Requiring type annotations in subprogram definitions is obligatory, which means the compiler almost never needs you to use them elsewhere in the code to figure out what you mean. Subprogram can parameter overloaded too. It makes possible to create multiple subprogram of the same name with different implementations. Calls to an overloaded subprogram will run a specific implementation of that subprogram appropriate to the context of the call, allowing one subprogram call to perform different tasks depending on context:\nfun retBigger(el2, el2: int): int = { return el1 | this \u0026gt; el2 | el2 } fun retBigger(el2, el2: flt): flt = { return el1 | this \u0026gt; el2 | el2 } pro main: int = { retBigger(4, 5); // calling a subprogram with intigers retBigger(4.5, .3); // calling another subprogram with same name but floats } The overloading resolution algorithm determines which subprogram is the best match for the arguments. Example:\npro toLower(c: char): char = { // toLower for characters if (c in {'A' ... 'Z'}){ result = chr(ord(c) + (ord('a') - ord('A'))) } else { result = c } } pro toLower(s: str): str = { // toLower for strings result = newString(.len(s)) for i in {0 ... len(s) - 1}: result[i] = toLower(s[i]) // calls toLower for characters; no recursion! } Actual parameters Subprogram call statements must include the name of the subprogram and a list of parameters to be bound to the formal parameters of the subprogram. These parameters are called actual parameters. They must be distinguished from formal parameters, because the two usually have different restrictions on their forms.\nPositional parameters The correspondence between actual and formal parameters, or the binding of actual parameters to formal parameters - is done by position: The first actual parameter is bound to the first formal parameter and so forth. Such parameters are called positional parameters. This is an effective and safe method of relating actual parameters to their corresponding formal parameters, as long as the parameter lists are relatively short.\nfun[] calc(el1, el2, el3: int): int = { result = el1 + el2 - el3 } pro main: int = { calc(3,4,5); // calling subprogram with positional arguments } Keyword parameters When parameter lists are long, however, it is easy to make mistakes in the order of actual parameters in the list. One solution to this problem is with keyword parameters, in which the name of the formal parameter to which an actual parameter is to be bound is specified with the actual parameter in a call. The advantage of keyword parameters is that they can appear in any order in the actual parameter list.\nfun[] calc(el1, el2, el3: int): int = { result = el1 + el2 - el3 } pro main: int = { calc(el3 = 5, el2 = 4, el1 = 3); // calling subprogram with keywords arguments } Mixed parameters Keyword and positional arguments can be used at the same time too. The only restriction with this approach is that after a keyword parameter appears in the list, all remaining parameters must be keyworded. This restriction is necessary because a position may no longer be well defined after a keyword parameter has appeared.\nfun[] calc(el1, el2, el3: int, el4, el5: flt): int = { result[0] = ((el1 + el2) * el4 ) - (el3 ** el5); } pro main: int = { calc(3, 4, el5 = 2, el4 = 5, el3 = 6); // element $el3 needs to be keyeorded at the end because // its positional place is taken by keyword argument $el5 } Default arguments Formal parameters can have default values too. A default value is used if no actual parameter is passed to the formal parameter. The default parameter is assigned directly after the formal parameter declaration. The compiler converts the list of arguments to an array implicitly. The number of parameters needs to be known at compile time.\nfun[] calc(el1, el2, el3: rise: bool = true): int = { result[0] = el1 + el2 * el3 | this | el1 + el2; } pro main: int = { calc(3,3,2); // this returns 6, last positional parameter is not passed but // the default `true` is used from the subprogram declaration calc(3,3,2,false) // this returns 12 } Variadic subprograms The use of ... as the type of argument at the end of the argument list declares the subprogram as variadic. This must appear as the last argument of the subprogram. When variadic subprograms are used, the default arguments can not be used at the same time.\nfun[] calc(rise: bool; ints: ... int): int = { result[0] = ints[0] + ints[1] + ints[2] * ints[3] | this | ints[0] + ints[1]; } pro main: int = { calc(true,3,3,3,2); // this returns 81, four parmeters are passed as variadic arguments calc(true,3,3,2) // this returns 0, as the subprogram multiplies with the forth varadic parameter // and we have given only three (thus the forth is initialized as zero) } ... is called unpack operator - just like in Golang. In the subprogram above, you see ..., which means pack all incoming arguments into seq[int] after the first argument. The sequence then is turned into a list at compile time.\nNested functions Nested procedures don't have access to the outer scope, while nested function have but can't change the state of it.  Return The return type of the subprogram has to always be defined, just after the formal parameter definition. Following the general rule of FOL:\nfun[] add(el1, el2: int[64]): int[64] = { result = el1 + el2 } To make it shorter (so we don\u0026rsquo;t have to type int[64] two times), we can use a short form by omitting the return type. The compiler then will assign the returntype the same as the functions return value.\nfun[] add(el1, el2: int[64]) = { result = el1 + el2 } Each function in FOL has two defined variables that are automatically returned at the end of the function:   a variable called result, which is the one that is returned and is same type as return type an error variable (called error), that can be reported from the funciton  Internally, FOL creates a set of two variables, set[result: any, eror: err]. The result is of type any, and the any type shoud be known at compile time.  The implicitly declared variable result is of the same type of the return type. For it top be implicitly declared, the return type of the function shoud be always declared, and not use the short form. The variable is initialized with zero value, and if not changed during the body implementation, the same value will return (so zero).\npro main(): int = { fun[] add(el1, el2: int[64]): int[64] = { result = el1 + el2 } // using the implicitly declared $result variable fun[] sub(el1, el2: int[64]) = { return el1 - el2 } // can't access the result variable, thus we use return } In addition, another implicitly decpared variable error of ype err is declared too. We talk for errors in details here, but here is a short example:\npro main(): int = { fun[] add(el1, el2: int[64]): int[64] = { result = el1 + el2 } // using the implicitly declared $result variable check(add(5,6)) // this will check if the error is nil } The final expression in the function will be used as return value. For this to be used, the return type of the function needs to be defined (so the function cnat be in the short form)). ver this can be used only in one statement body.\npro main(): int = { fun[] add(el1, el2: int[64]): int[64] = { el1 + el2 } // This is tha last statement, this will serve as return fun[] someting(el1,el2: int): int = { if (condition) { } else { } el1 + el2 // this will throw an error, cand be used in kulti statement body } fun[] add(el1, el2: int[64]) = { el1 + el2 } // this will throw an error, we can't use the short form of funciton in this way Alternatively, the return and report statements can be used to return a value or error earlier from within the function, even from inside loops or other control flow mechanisms.\nThe example below is just to show the return and report statements, there is a better way to handle errors as shown in error section\nuse file: mod[std] = { std::fs::File } pro main(): int = { fun[] fileReader(path: str): str = { var aFile = file.readfile(path) if ( check(aFile) ) { report \u0026quot;File could not be opened\u0026quot; + file // report will not break the program, but will return the error here, and the funciton will stop } else { return file | stringify(this) | return $ // this will be executed only if file was oopened without error } } } Procedurues Procedures are most common type of subprograms in Fol. When a procedure is \u0026ldquo;called\u0026rdquo; the program \u0026ldquo;leaves\u0026rdquo; the current section of code and begins to execute the first line inside the procedure. Thus the procedure \u0026ldquo;flow of control\u0026rdquo; is:\n The program comes to a line of code containing a \u0026ldquo;procedure call\u0026rdquo;. The program enters the procedure (starts at the first line in the procedure code). All instructions inside of the procedure are executed from top to bottom. The program leaves the procedure and goes back to where it started from. Any data computed and RETURNED by the procedure is used in place of the procedure in the original line of code.  Procedures have side-effects, it can modifies some state variable value(s) outside its local environment, that is to say has an observable effect besides returning a value (the main effect) to the invoker of the operation. State data updated \u0026ldquo;outside\u0026rdquo; of the operation may be maintained \u0026ldquo;inside\u0026rdquo; a stateful object or a wider stateful system within which the operation is performed.\nPassing values The semantics for passing a value to a procedure are similar to those for assigning a value to a variable. Passing a variable to a procedure will move or copy, just as assignment does. If the procedure is stack-based, it will automatically copy the value. If it is heap-based, it will move the value.\npro[] modifyValue(someStr: str) = { someStr = someStr + \u0026quot; world!\u0026quot; } pro[] main: int = { //case1 var[mut] aString: str = \u0026quot;hello\u0026quot;; // a string varibale $aString is declared (in stack as default) modifyValue(aString); // the value is passed to a procedure, since $aVar is in stack, the value is copied .echo(aString) // this prints: \u0026quot;hello\u0026quot;, // value is not changed and still exists here, because was copied //case2 @var[mut] aString: str = \u0026quot;hello\u0026quot;; // a string varibale $bString is declared (in stack with '@') modifyValue(bString); // the value is passed to a procedure, since $aVar is in heap, the value is moved .echo(bString) // this throws ERROR, // value does not exists anymore since it moved and ownership wasn't return } As you can see from above, in both cases, the .echo(varable) does not reach the desired procedure, to print hello world!. In first case is not changed (because is coped), in second case is changed but never returned. To fix the second case, we can just use the .give_back() procedure to return the ownership:\npro[] modifyValue(someStr: str) = { someStr = someStr + \u0026quot; world!\u0026quot; .give_back(someStr) // this returns the ownership (if there is an owner, if not just ignores it) } pro[] main: int = { //case1 var[mut] aString: str = \u0026quot;hello\u0026quot;; // a string varibale $aString is declared (in stack as default) modifyValue(aString); // the value is passed to a procedure, since $aVar is in stack, the value is copied .echo(aString) // this still prints: \u0026quot;hello\u0026quot;, // value is not changed and still exists here, because was copied //case2 @var[mut] aString: str = \u0026quot;hello\u0026quot;; // a string varibale $bString is declared (in stack with '@') modifyValue(bString); // the value is passed to a procedure, since $aVar is in heap, the value is moved .echo(aString) // this now prints: \u0026quot;hello world!\u0026quot;, // value now exists since the ownership is return } Lend parameters But now, we were able to change just the variable that is defined in heap (case two), by moving back the ownership. In case one, since the value is copied, the owner of newly copied value is the procedure itself. So the .give_back() is ignored. To fix this, we use borrowing to lend a value to the procedure\npro[] modifyValue((someStr): str) = { // we use `(someStr)` to mark it as borrowable someStr = someStr + \u0026quot; world!\u0026quot; } pro[] main: int = { //case1 var[mut] aString: str = \u0026quot;hello\u0026quot;; // a string varibale $aString is declared (in stack as default) modifyValue(aString); // the value is lended to the procedure .echo(aString) // this now prints: \u0026quot;hello world!\u0026quot;, //case2 @var[mut] aString: str = \u0026quot;hello\u0026quot;; // a string varibale $bString is declared (in stack with '@') modifyValue(aString); // the value is lended to the procedure .echo(aString) // this now prints: \u0026quot;hello world!\u0026quot;, } So to make a procedure borrow a varibale it uses (varName).\npro[] borrowingProcedure(aVar: str; (bVar): bol; cVar, (dVar): int) To call this procedure, the borrowed parameters always shoud be a variable name and not a direct value:\nvar aBool, anInt = true, 5 borrowingProcedure(\u0026quot;get\u0026quot;, true, 4, 5) // this will throw an error, cos it expects borrowable not direct value borrowingProcedure(\u0026quot;get\u0026quot;, aBool, 4, anInt) // this is the proper way If all parameters are going to be borrowable, then the procedure can encapsulate all the parameters in double brackets (( //parameters )):\npro[] borrowingProcedure((aVar: str; bVar: bol; cVar, dVar: int)) When the value is passed as borrowable in procedure, by default it gives premission to change, so the same as var[mut, bor] as disscussed here.\nReturn ownership Return values can be though as return of ownership too. The ownership of a variable follows the same pattern every time: assigning a value to another variable moves or copies it.\npro main(): int = { var s1 = givesOwnership(); // the variable $s1 is given the ownership of the procedure's $givesOwnership return .echo(s1) // prints \u0026quot;hi\u0026quot; var s2 = returnACopy(); // the variable $s2 is given the ownership of the procedure's $returnACopy return .echo(s2) // prints: \u0026quot;there\u0026quot; } pro givesOwnership(): str = { // This procedure will move its return value into the procedure that calls it @var someString = \u0026quot;hi\u0026quot;; // $someString comes into scope return someString // $someString is returned and MOVES out to the calling procedure } pro returnACopy(): int = { // This procedure will move its return value into the procedure that calls it var anotherString = \u0026quot;there\u0026quot; // $anotherString comes into scope return anotherString // $anotherString is returned and COPIES out to the calling procedure } When a variable that includes data on the heap goes out of scope, the value will be cleaned up automatically by .de_alloc() unless the data has been moved to be owned by another variable, in this case we give the ownership to return value. If the procedure with the retun value is not assigned to a variable, the memory will be freed again.\nWe can even do a transfer of ownership by using this logic:\npro main(): int = { @var s2 = \u0026quot;hi\u0026quot;; // $s2 comes into scope (allocatd in the heap) var s3 = transferOwnership(s2); // $s2 is moved into $transferOwnership procedure, which also gives its return ownership to $s3 .echo(s3) // prints: \u0026quot;hi\u0026quot; .echo(s2) // this throws an error, $s2 is not the owner of anything anymore } pro transferOwnership(aString: str): str = { // $aString comes into scope return aString // $aString is returned and moves out to the calling procedure } This does not work with borrowing though. When a variable is lended to a procedure, it has permissions to change, but not lend to someone else. The only thing it can do is make a .deep_copy() of it:\npro main(): int = { @var s2 = \u0026quot;hi\u0026quot;; // $s2 comes into scope (allocatd in the heap) var s3 = transferOwnership(s2); // $s2 is moved into $transferOwnership procedure, which also gives its return ownership to $s3 .echo(s3) // prints: \u0026quot;hi\u0026quot; .echo(s2) // prints: \u0026quot;hi\u0026quot; too } pro transferOwnership((aString: str)): str = { // $aString comes into scope which is borrowed return aString // $aString is borrowed, thus cant be lended to someone else // thus, the return is a deep_copy() of $aString } Functions Functions compared to procedure are pure. A pure function is a function that has the following properties:\n Its return value is the same for the same arguments (no variation with local static variables, non-local variables, mutable reference arguments or input streams from I/O devices). Its evaluation has no side effects (no mutation of local static variables, non-local variables, mutable reference arguments or I/O streams).  Thus a pure function is a computational analogue of a mathematical function. Pure functions are declared with fun[]\nfun[] add(el1, el2: int[64]): int[64] = { result = el1 + el2 } Functions that are pure are lazy-initialized in Fol. So it is an evaluation strategy which delays the evaluation of the function until its value is needed. You call a function passing it some arguments that were expensive to calculate and then the function don’t need all of them due to some other arguments.\nConsider a function that logs a message:\nlog.debug(\u0026quot;Called foo() passing it \u0026quot; + .to_string(argument_a) + \u0026quot; and \u0026quot; + .to_string(argument_b)); The log library has various log levels like “debug”, “warning”, “error” etc. This allows you to control how much is actually logged; the above message will only be visible if the log level is set to the “debug” level. However, even when it is not shown the string will still be constructed and then discarded, which is wasteful.\nSince Fol supports first class functions, it allows functions to be assigned to variables, passed as arguments to other functions and returned from other functions.  Anonymous functoins Anonymous function is a function definition that is not bound to an identifier. These are a form of nested function, in allowing access to variables in the scope of the containing function (non-local functions).\nStaring by assigning a anonymous function to a vriable:\nvar[] f = fun[] (a, b: int): int = { // assigning a variable to function return a + b } .echo(f(5,6)) // prints 11 It is also possible to call a anonymous function without assigning it to a variable.\nfun[] (a, b: int) = { //define anonymous function .echo(a + b) }(5, 6) //calling anonymous function Closures Functions can appear at the top level in a module as well as inside other scopes, in which case they are called nested functions. A nested function can access local variables from its enclosing scope and if it does so it becomes a closure. Any captured variables are stored in a hidden additional argument to the closure (its environment) and they are accessed by reference by both the closure and its enclosing scope (i.e. any modifications made to them are visible in both places). The closure environment may be allocated on the heap or on the stack if the compiler determines that this would be safe.\nThere are two types of closures:\n anonymous named  Anonymus closures automatically capture variables, while named closures need to be specified what to capture. For capture we use the [] just before the type declaration.\nfun[] add(n: int): int = { fun added(x: int)[n]: int = { // we make a named closure return x + n // variable $n can be accesed because we have captured ti } return adder() } var added = add(1) // assigning closure to variable added(5) // this returns 6 fun[] add(n: int): int = { return fun(x: int): int = { // we make a anonymous closure return x + n // variable $n can be accesed from within the nested function } } Currying Currying is converting a single function of \u0026ldquo;n\u0026rdquo; arguments into \u0026ldquo;n\u0026rdquo; functions with a \u0026ldquo;single\u0026rdquo; argument each. Given the following function:\nfun f(x,y,z) = { z(x(y));} When curried, becomes:\nfun f(x) = { fun(y) = { fun(z) = { z(x(y)); } } } And calling it woud be like:\nf(x)(y)(z) However, the more iportant thing is taht, currying is a way of constructing functions that allows partial application of a function’s arguments. What this means is that you can pass all of the arguments a function is expecting and get the result, or pass a subset of those arguments and get a function back that’s waiting for the rest of the arguments.\nfun calc(x): int = { return fun(y): int = { return fun (z): int = { return x + y + z } } } var value: int = calc(5)(6) // this is okay, the function is still finished var another int = value(8) // this completes the function var allIn: int = calc(5)(6)(8) // or this as alternative Higer-order functions A higher-order function is a function that takes a function as an argument. This is commonly used to customize the behavior of a generically defined function, often a looping construct or recursion scheme.\nThey are functions which do at least one of the following:\n takes one or more functions as arguments returns a function as its result  //function as parameter fun[] add1({fun adder(x: int): int}): int = { return adder(x + n) } //function as return fun[] add2(): {fun (x: int): int} = { var f = fun (a, b: int): int = { return a + b } return f } Methods There is another type of subprogram, called method, but it can be either a pure function either a procedure. A method is a piece of code that is called by a name that is associated with an object where it is implicitly passed the object on which it was called and is able to operate on data that is contained within the object.\nThey either are defined inside the object, or outside the object then the object in which they operate is passed like so (just like in Golang):\npro (object)getDir(): str = { result = self.dir; }; ","description":"","id":28,"section":"docs","tags":null,"title":"Functions","uri":"https://follang.org/docs/spec/functions/"},{"content":"Unlike other programming languages, FOL does not have exceptions (Rust neither). It has only two types of errors:\n braking errors recoverable errors  Breaking errors cause a program to fail abruptly. A program cannot revert to its normal state if an unrecoverable error occurs. It cannot retry the failed operation or undo the error. An example of an unrecoverable error is trying to access a location beyond the end of an array.\nRecoverable error are errors that can be corrected. A program can retry the failed operation or specify an alternate course of action when it encounters a recoverable error. Recoverable errors do not cause a program to fail abruptly. An example of a recoverable error is when a file is not found.\nThere are two keywords reserved and associated to two types of errors: report for a recoverable error and panic for the braking error.\nBreaking error panic keyword allows a program to terminate immediately and provide feedback to the caller of the program. It should be used when a program reaches an unrecoverable state. This most commonly occurs when a bug of some kind has been detected and it’s not clear to the programmer how to handle the error.\npro main(): int = { panic \u0026quot;Hello\u0026quot;; .echo(\u0026quot;End of main\u0026quot;); //unreachable statement } In the above example, the program will terminate immediately when it encounters the panic keyword.\nOutput:\nmain.fol:3 routine 'main' panicked at 'Hello' ------- Trying to acces an out of bound element of array:\npro main(): int = { var a: arr[int, 3] = [10,20,30]; a[10]; //invokes a panic since index 10 cannot be reached } Output:\nmain.fol:4 routine 'main' panicked at 'index out of bounds: the len is 3 but the index is 10' ------- a[10]; ^-------- index out of bounds: the len is 3 but the index is 10 A program can invoke panic if business rules are violated, for example: if the value assigned to the variable is odd it throws an error:\npro main(): int = { var no = 13; //try with odd and even if (no % 2 == 0) { .echo(\u0026quot;Thank you , number is even\u0026quot;); } else { panic \u0026quot;NOT_AN_EVEN\u0026quot;; } .echo(\u0026quot;End of main\u0026quot;); } Output:\nmain.fol:9 routine 'main' panicked at 'NOT_AN_EVEN' ------- Recoverable error report can be used to handle recoverable errors. As discussed here, FOL uses two variables result nd error in return of each subprogram. As name implies, result represents the type of the value that will be returned in a success case, and error represents the type of the error err[] that will be returned in a failure case.\nWhen we use the keyword report, the error is returned to the subprogram\u0026rsquo;s error variable and the subprogram qutis executing (the subprogram, not the program).\nuse file: mod[std] = { std::fs::File } pro main(): int = { pro[] fileReader(path: str): str = { var aFile = file.readfile(path) if ( check(aFile) ) { report \u0026quot;File could not be opened\u0026quot; + file // report will not break the program, but will return the error here, and the subprogram will stop } else { return file.to_string() // this will be executed only if file was oopened without error } } } Form this point on, the error is concatinated up to the main function. This is known as propagating the error and gives more control to the calling code, where there might be more information or logic that dictates how the error should be handled than what you have available in the context of your code.\nuse file: mod[std] = { std::fs::File } pro main(): int = { var f = file.open(\u0026quot;main.jpg\u0026quot;); // main.jpg doesn't exist if (check(f)) { report \u0026quot;File could not be opened\u0026quot; + file // report will not break the program } else { .echo(\u0026quot;File was open sucessfulley\u0026quot;) // this will be executed only if file was oopened without error } } By default, all errors are either conctinated up with report, or exited with panic.  A simplier way to hande errors is through pipes\n","description":"","id":30,"section":"docs","tags":null,"title":"Errors","uri":"https://follang.org/docs/spec/errors/"},{"content":"Piping is a process that connects the output of the expression to the left to the input of the expression of the right. You can think of it as a dedicated program that takes care of copying everything that one expressionm prints, and feeding it to the next expression. The idea is the same as bash pipes. For example, an subprogram output is piped to a conditional through pipe symbol | then the conditional takes the input and returns true or false. If returned false, then the second part of pipe is returned. To access the piped variable, this keyword is used:\npro[] main: int = { fun addFunc(x, y: int): int = { return x + y; } var aVar: int = addFunc(4, 5) | if(this \u0026gt; 8) | return 6; } However, when we assign an output of a function to a variable, we shoud expect that errors within funciton can happen. By default, everytime a function is called, and the function throws an error in will be reported up.\nvar aVar: int = addFunc(4, 5); // if there are errors, and the call is in main function, the program will exit // because is the last concatinator of the 'report' error However, when we use pipes, we pass the function values (result and the error) to the next expression, and then, it is the second expression\u0026rsquo;s responsibility to deal with it. We use the built-in check that checks for error on the function:\nvar aVar: int = addFunc(4, 5) | check(this) | return 5; // if there are errors, the error is passed to the next sepression with pipe // here, if there is errors, will be checked and the default value of 5 will return There is a shorter way to do this kind of error checking. For that we use double pipe ||. For example, we assign the output of a function to a variable, but the function may fail, so we want a default variable:\nvar aVar: int = addFunc(4, 5) || return 5; Or to handle the error ourselves. This simply says, if i get the error, then we can panic or report with custom message:\nvar aVar: int = addFunc(4, 5) || panic \u0026quot;something bad inside function has happened\u0026quot;; More on error handling can be found here\n","description":"","id":32,"section":"docs","tags":null,"title":"Pipes","uri":"https://follang.org/docs/spec/pipes/"},{"content":"Concurrency is the ability of different tasks of a program to be executed out-of-order or in partial order, without affecting the final outcome. This allows for parallel execution of the concurrent tasks, which can significantly improve overall speed of the execution in multi-processor and multi-core systems. In more technical terms, concurrency refers to the decomposability property of a program into order-independent or partially-ordered tasks.\nThere are two distinct categories of concurrent task control.\n The most natural category of concurrency is that in which, assuming that more than one processor is available, several program tasks from the same program literally execute simultaneously. This is physical concurrency - parallel programming. Or programm can assume that there are multiple processors providing actual concurrency, when in fact the actual execution of programs is taking place in interleaved fashion on a single processor. This is logical concurrency concurrent programming.  From the programmer’s points of view, concurrency is the same as parallelism. It is the language’s task, using the capabilities of the underlying operating system, to map the logical concurrency to the host hardware.\nThere are at least four different reasons to use concurrency:\n The first reason is the speed of execution of programs on machines with multiple processors. The second reason is that even when a machine has just one processor, a program written to use concurrent execution can be faster. The third reason is that concurrency provides a different method of conceptualizing program solutions to problems. The fourth reason for using concurrency is to program applications that are distributed over several machines, either locally or network.  Tasks A task is a unit of a program, similar to a subprogram, that can be in concurrent execution with other units of the same program. Each task in a program can support one thread of control.\nThree characteristics of tasks distinguish them from subprograms.\n First, a task may be implicitly started, whereas a subprogram must be explicitly called. Second, when a program unit invokes a task, in some cases it need not wait for the task to complete its execution before continuing its own. Third, when the execution of a task is completed, control may or may not return to the unit that started that execution.  In fol to sent a assign a subprogram to a task, we use the symbols \u0026gt;\u0026gt;\nChannels pro main(): int = { var something: chn[str, 4]; ~var found: bol; for (i in 0 ... 4) { \u0026gt;\u0026gt; doItFast(i, found) | [\u0026gt;]something } var fromCh1 = [\u0026lt;]something[0] } fun doItFast(i: int; found: bol): str = { } Async/Await pro main(): int = { \u0026gt;\u0026gt; fun doItFast(): int[64] = { var result = client.get((address)).send() | await } } ","description":"","id":34,"section":"docs","tags":null,"title":"Concurrency","uri":"https://follang.org/docs/spec/concurrency/"},{"content":"A type declaration binds an identifier, the type name, to a type. Type declarations come in two forms:\n alias declarations and type definitions (objects): records, enums, units and classes.  Alias declaration An alias declaration binds an identifier to the given type. All the properties of the type are bound to the alias too: credit to golang:\ntyp[pub] I5: arr[int, 5]; So now the in the code, instead of writing arr[int, 5] we could use I5:\n~var[pub] fiveIntigers: I5 = { 0, 1, 2, 3, 4, 5 } Alias declaration are created because they can simplify using them multiple times, their identifier (their name) may be expressive in other contexts, and–most importantly–so that you can define (attach) methods to it (you can\u0026rsquo;t attach methods to built-in types, nor to anonymous types or types defined in other packages).\nAttaching methods is of outmost importance, because even though instead of attaching methods you could just as easily create and use functions that accept the \u0026ldquo;original\u0026rdquo; type as parameter, only types with methods can implement standards std[] that list/enforce those methods, and you can\u0026rsquo;t attach methods to certain types unless you create a new type derived from them.\nType definition Records A type definition creates a new, distinct type - a record. A record is an aggregate of data elements in which the individual elements are identified by names and types and accessed through offsets from the beginning of the structure. There is frequently a need in programs to model a collection of data in which the individual elements are not of the same type or size. For example, information about a college student might include name, student number, grade point average, and so forth. A data type for such a collection might use a character string for the name, an integer for the student number, a floating- point for the grade point average, and so forth. Records are designed for this kind of need.\nIt may appear that records and heterogeneous set are the same, but that is not the case. The elements of a heterogeneous set[] are all references to data objects that reside in scattered locations, often on the heap. The elements of a record are of potentially different sizes and reside in adjacent memory locations. Records are normally used as encapsulation structures, rather than data structures.\ntyp user: rec = { username: str, email: str, sign_in_count: int[64], active: bol, }; To use a record after we’ve defined it, we create an instance of that record by specifying concrete values for each of the fields. We create an instance by stating the name of the record and then add curly brackets containing key: value pairs, where the keys are the names of the fields and the values are the data we want to store in those fields. We don’t have to specify the fields in the same order in which we declared them in the record. In other words, the record definition is like a general template for the type, and instances fill in that template with particular data to create values of the type.\n@var user1: user = { email = \u0026quot;someone@example.com\u0026quot;, username = \u0026quot;someusername123\u0026quot;, active = true, sign_in_count = 1, }; Initializaion can be inline too:\n@var[mut] user1: user = { email = \u0026quot;someone@example.com\u0026quot;, username = \u0026quot;someusername123\u0026quot;, active = true, sign_in_count = 1 } To get a specific value from a record, we can use dot notation or the access brackets. If we wanted just this user’s email address, we could use user1.email or user1[email] wherever we wanted to use this value. If the instance is mutable, we can change a value by assigning into a particular field. Note that the entire instance must be mutable; FOL doesn’t allow us to mark only certain fields as mutable.\n@var[mut] user1: user = { email = \u0026quot;someone@example.com\u0026quot;, username = \u0026quot;someusername123\u0026quot;, active = true, sign_in_count = 1, }; user1.email = \u0026quot;new.mail@example.com\u0026quot; user1[username] = \u0026quot;anotherusername\u0026quot; As with any expression, we can construct a new instance of the record as the last expression in the function body to implicitly return that new instance. As specified in function return, the final expression in the function will be used as return value. For this to be used, the return type of the function needs to be defined (here is defined as user) and this can be used only in one statement body. Here we have declared only one variable user1 and that itslef spanc into multi rows:\npro buildUser(email, username: str): user = { user1: user = { email = \u0026quot;someone@example.com\u0026quot;, username = \u0026quot;someusername123\u0026quot;, active = true, sign_in_count = 1, } } Records can be nested by creating a record type using other record types as the type for the fields of record. Nesting one record within another can be a useful way to model more complex structures:\nvar empl1: employee = { FirstName = \u0026quot;Mark\u0026quot;, LastName = \u0026quot;Jones\u0026quot;, Email = \u0026quot;mark@gmail.com\u0026quot;, Age = 25, MonthlySalary = { Basic = 15000.00, Bonus = { HTA = 2100.00, RA = 5000.00, }, }, } A record may have methods associated with it. It does not inherit any methods bound to the given type, but the method set of an standard type remains unchanged.To create a method for a record, it needs to be declared as the reciever of that method, in FOL\u0026rsquo;s. Making a getter fucntion:\nfun (recieverRecord)someFunction(): str = { self.somestring; }; After declaring the record receiver, we then we have access to the record with the keyword self. A receiver is essentially just a type that can directly call the method.\ntyp user: rec = { username: str, email: str, sign_in_count: int[64], active: bol, }; fun (user)getName(): str = { result = self.username; }; Methods have some benefits over regular subprograms. In the same package subprograms with the same name are not allowed but the same is not true for a method. One can have multiple methods with the same name given that the receivers they have are different.\nThen each instantiation of the record can access the method. Receivers allow us to write method calls in an OOP manner. That means whenever an object of some type is created that type can call the method from itself.\nvar[mut] user1: user = { email = \u0026quot;someone@example.com\u0026quot;, username = \u0026quot;someusername123\u0026quot;, active = true, sign_in_count = 1 } .echo(user1.getName()); Records can have default values in their fields too.\ntyp user: rec = { username: str, email: str, sign_in_count: int[64] = 1, active: bol = true, }; This makes possible to enforce some fields (empty ones), and leave the defaults untouched:\n@var[mut] user1: user = { email = \u0026quot;someone@example.com\u0026quot;, username = \u0026quot;someusername123\u0026quot; } Structs Compared to records, structs cant have neither named values, neither default values  Structs are simplified version of records. The are identified with stc[] keyword. Structs have the added meaning the record name provides but don’t have names associated with their fields; rather, they just have the types of the fields. Structs are useful when you want to give a set[] a name and make the tuple be a different type from other sets, and naming each field as in a regular record would be verbose or redundant.\ntyp regStc: stc = { int[8], str, } And the difference between a struct and aliased type to set is that, in a struct you can restrict the values (with ranges) assigned to each field:\ntyp rgbSet: set[int[8], int[8], int[8]]; typ regStc: stc = { int[8][.range(0 ... 255)]; int[8][.range(0 ... 255)]; int[8][.range(0 ... 255)]; } This of course can be achieve just with variable types and aliased types too, but we would need to create two types:\ntyp rgb: int[8][.range(0 ... 255)] ; // we create a type that holds only number from 0 to 255 typ rgbSet: set[rgb, rgb, rgb]; // then we create a type holding the `rgb` type Enums Is an enumerated type (also called enumeration, enm) is a data type consisting of a set of named values called elements. It can have only one type of data and no methods, and new members can be added:\ntyp color: enm = { BLUE, RED, BLACK, WHITE: str = \u0026quot;#0037cd\u0026quot;, \u0026quot;#ff0000\u0026quot;, \u0026quot;#000000\u0026quot;, \u0026quot;#FFFFFF\u0026quot;; }; color.add(GREEN) = \u0026quot;#ff0000\u0026quot;; if( something == color.BLUE ) { dosomething } else { donothing } Classes Calsses are the way that FOL can apply OOP. They basically are a glorified record. Instead of methods to be used fom outside the body, they have the method declaration within the body.\nHere are some ways that class can be defined. For example, creating an class filer that inherits from class called system and can be modified if inherited by another classes.\ntyp[pub,~] computer(system): cls = { var[pub] dir: str; var[pub] size: int[16]; +fun aMethod(var1: int, var2: str): str = { return; }; } var laptop: computer = { member1 = value, member2 = value; }; laptop.aMethod(5, \u0026quot;dell\u0026quot;); Standards and Contracts Satndard A standard is an established norm or requirement for a repeatable technical task. It is usually a formal declaration that establishes uniform technical criteria, methods, processes, and practices.\nS, what is a to be considered a standard:\n A standard specification is an explicit set of requirements for an item, object or service. It is often used to formalize the technical aspects of a procurement agreement or contract. A standard test method describes a definitive procedure that produces a test result. It may involve making a careful personal observation or conducting a highly technical measurement. A standard procedure gives a set of instructions for performing operations or functions. A standard guide is general information or options that do not require a specific course of action. A standard definition is formally established terminology.  In FOL, standards are named collection of method signatures and are created by using std keyword:\ntyp geometry: std = { fun area(): flt[64]; fun perim(): flt[64]; }; There are two types of standards, the normal ones that enforce just function implementation and extended, that enforce inclusion too:\ntyp geometry: std = { fun area(): flt[64]; fun perim(): flt[64]; }; typ geometry: std[ext] = { // extended standard that enforces inclusion fun area(): flt[64]; fun perim(): flt[64]; color: rgb; // every type that uses tis standard mus have a color variable member as `rgb` type }; Contract A contract is a legally binding agreement that recognises and governs the rights and duties of the parties to the agreement. A contract is enforceable because it meets the requirements and approval of an higher authority. An agreement typically involves a written declaration given in exchange for something of value that binds the maker to do. Its an specific act which gives to the person to whom the declaration is made the right to expect and enforce performance. In the event of breach of contract, the higher authority will refrain the contract from acting.\nIn fol contracts are used to bind a type to a standard. If a type declares to use a standard, it is the job of the contract (compiler internally) to see the standard full-filled.\ntyp geo: std = { fun area(): flt[64]; fun perim(): flt[64]; }; typ rect(geo): rec[] = { // this type makes a contract to use the geometry standard width: int[64]; heigh: int[64]; } Now we can make rect records or classes, we have to respect the contract. If we don\u0026rsquo;t implement the geo methods, when we instantiate a new object of type rect it will throw an error.\nvar aRectangle: rect = { width = 5; heigh = 6; } // this throws an error, we haven't fullfill the ocntract To do so, we need first to create the default rect methods from geo standard, then instantiate a new object:\nfun (rect)area(): flt[64] = { result = self.width + self.heigh } fun (rect)perim(): flt[64] = { result = 2 * self.width + 2 * self.heigh } var aRectangle: rect = { width = 5; heigh = 6; } // this from here on will work The benifit of standard is that, we can create a subprogram that as parameter takes a standard, thus all objects with the standard can use afterwards that subprogram:\ntyp geo: std = { fun area(): flt[64]; fun perim(): flt[64]; }; typ rect(geo): rec[] = { // this type makes a contract to use the geometry standard width: int[64]; heigh: int[64]; } fun (rect)area(): flt[64] = { result = self.width + self.heigh } fun (rect)perim(): flt[64] = { result = 2 * self.width + 2 * self.heigh } typ circle(geo): rec[] = { // another type makes a contract to use the geometry standard radius: int[64]; } fun (circle)area(): flt[64] = { result = math::const.pi * self.radius ** 2 } fun (circle)perim(): flt[64] = { result = 2 * math::const.pi * self.radius} typ square: rec[] = { // this type does not make contract with `geo` heigh: int[64] } pro measure( standard: std) { .echo(standard.area() + \u0026quot;m2\u0026quot;) } // a siple method to print the standard's area // instantiate two objects var aRectangle: rect = { width = 5; heigh = 6; } // creating a new rectangle var aCircle: circle = { radius = 5; } // creating a new rectangle var aSquare: square = { heigh = 6; } // creating a new square // to call the measure function that rpints the surface measure(aRectangle) // this prints: 30m2 measure(aSquare) // this throws error, square cant use measure method measure(aCircle) // this prints: 78m2 ","description":"","id":36,"section":"docs","tags":null,"title":"Objects","uri":"https://follang.org/docs/spec/objects/"},{"content":"Generic functions - lifting The generic programming process focuses on finding commonality among similar implementations of the same algorithm, then providing suitable abstractions so that a single, generic algorithm can cover many concrete implementations. This process, called lifting, is repeated until the generic algorithm has reached a suitable level of abstraction, where it provides maximal reusability while still yielding efficient, concrete implementations. The abstractions themselves are expressed as requirements on the parameters to the generic algorithm.\npro max(T: gen)(a, b: T): T { result = a | a \u0026lt; b | b; }; fun biggerFloat(a, b: flt[32]) flt[32] { return max(flt[32])(a, b); }; fun biggerInteger(a, b: int[64]) int[64] { return max(int[64])(a, b); }; Generic types - concepts Once many algorithms within a given problem domain have been lifted, we start to see patterns among the requirements. It is common for the same set of requirements to be required by several different algorithms. When this occurs, each set of requirements is bundled into a concept. A concept contains a set of requirements that describe a family of abstractions, typically data types. Examples of concepts include Input Iterator, Graph, and Equality Comparable. When the generic programming process is carefully followed, the concepts that emerge tend to describe the abstractions within the problem domain in some logical way.\ntyp container(T: gen, N: int)(): obj = { var anarray: arr[T,N]; +fun getsize(): num = { result = N; } }; var aContainer: container[int, 5] = { anarray = {zero, one, two, three, four}; }; ","description":"","id":38,"section":"docs","tags":null,"title":"Generics","uri":"https://follang.org/docs/spec/generics/"},{"content":"Lorem est tota propiore conpellat pectoribus de\npectora summo. Redit teque digerit hominumque toris verebor lumina non cervice\nsubde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc\ncaluere tempus\nThis article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\n Headings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae.\nNote that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\n Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Inline  Markdown  In  Table     italics bold strikethrough  code    Code Blocks Code block with backticks html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Code block with Hugo\u0026rsquo;s internal highlight shortcode \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Item  First Sub-item Second Sub-item    Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\n The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015. \u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":40,"section":"blog","tags":["markdown","css","html","themes"],"title":"Markdown Syntax Guide","uri":"https://follang.org/blog/markdown-syntax/"}]