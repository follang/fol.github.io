<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>FOL</title>
    <link>https://follang.org/</link>
    <description>Recent content on FOL</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>&amp;copy;{year}, FOL</copyright>
    <lastBuildDate>Sun, 26 Jan 2020 04:15:05 +0900</lastBuildDate>
    
        <atom:link href="https://follang.org/index.xml" rel="self" type="application/rss+xml" />
    
    
    
      
      <item>
        <title>May 2019</title>
        <link>https://follang.org/hub/2019_may/</link>
        <pubDate>Tue, 28 Jan 2020 00:10:51 +0900</pubDate>
        
        <guid>https://follang.org/hub/2019_may/</guid>
        <description>Markdown here</description>
      </item>
      
      <item>
        <title>April 2019</title>
        <link>https://follang.org/hub/2019_april/</link>
        <pubDate>Tue, 28 Jan 2020 00:10:48 +0900</pubDate>
        
        <guid>https://follang.org/hub/2019_april/</guid>
        <description>Markdown here</description>
      </item>
      
      <item>
        <title>March 2019</title>
        <link>https://follang.org/hub/2019_march/</link>
        <pubDate>Tue, 28 Jan 2020 00:10:42 +0900</pubDate>
        
        <guid>https://follang.org/hub/2019_march/</guid>
        <description>Markdown here</description>
      </item>
      
      <item>
        <title>February 2019</title>
        <link>https://follang.org/hub/2019_february/</link>
        <pubDate>Tue, 28 Jan 2020 00:10:37 +0900</pubDate>
        
        <guid>https://follang.org/hub/2019_february/</guid>
        <description>Markdown here</description>
      </item>
      
      <item>
        <title>January 2019</title>
        <link>https://follang.org/hub/2019_january/</link>
        <pubDate>Tue, 28 Jan 2020 00:10:09 +0900</pubDate>
        
        <guid>https://follang.org/hub/2019_january/</guid>
        <description>Markdown here</description>
      </item>
      
      <item>
        <title>Test 1</title>
        <link>https://follang.org/v0.11-docs/lex/test1/</link>
        <pubDate>Thu, 30 Jan 2020 00:38:25 +0900</pubDate>
        
        <guid>https://follang.org/v0.11-docs/lex/test1/</guid>
        <description></description>
      </item>
      
      <item>
        <title>Test 2</title>
        <link>https://follang.org/v0.11-docs/lex/static/test2/</link>
        <pubDate>Thu, 30 Jan 2020 00:38:25 +0900</pubDate>
        
        <guid>https://follang.org/v0.11-docs/lex/static/test2/</guid>
        <description></description>
      </item>
      
      <item>
        <title>Test 3</title>
        <link>https://follang.org/v0.11-docs/lex/static/dynamic/test3/</link>
        <pubDate>Thu, 30 Jan 2020 00:38:25 +0900</pubDate>
        
        <guid>https://follang.org/v0.11-docs/lex/static/dynamic/test3/</guid>
        <description></description>
      </item>
      
      <item>
        <title>ttttest</title>
        <link>https://follang.org/v0.11-docs/lex/ttttest/</link>
        <pubDate>Thu, 30 Jan 2020 00:38:25 +0900</pubDate>
        
        <guid>https://follang.org/v0.11-docs/lex/ttttest/</guid>
        <description></description>
      </item>
      
      <item>
        <title>Input</title>
        <link>https://follang.org/docs/100_lexical/input/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/docs/100_lexical/input/</guid>
        <description>FOL&amp;rsquo;s input is interpreted as a sequence of UNICODE code points encoded in UTF-8</description>
      </item>
      
      <item>
        <title>Modules</title>
        <link>https://follang.org/docs/400_modules/modules/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/docs/400_modules/modules/</guid>
        <description>Imoprting modules System libraries This is how including other libraries works, for example include fmt module from standard library:
use fmt: mod[std] = {fmt}; def main: mod[init] = { fmt::log.warn(&amp;quot;Last warning!...&amp;quot;) } To use only the log namespace of fmt module:
use log mod[std] = {fmt::log}; def main: mod[init] = { pro[] main: int = { log.warn(&amp;quot;Last warning!...&amp;quot;) } } But let&amp;rsquo;s say you only wanna use ONLY the warn functionality of log namespace from fmt module:</description>
      </item>
      
      <item>
        <title>Modules</title>
        <link>https://follang.org/v0.11-docs/spec/modules/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/v0.11-docs/spec/modules/</guid>
        <description>Imoprting modules System libraries This is how including other libraries works, for example include fmt module from standard library:
use fmt: mod[std] = {fmt}; def main: mod[init] = { fmt::log.warn(&amp;quot;Last warning!...&amp;quot;) } To use only the log namespace of fmt module:
use log mod[std] = {fmt::log}; def main: mod[init] = { pro[] main: int = { log.warn(&amp;quot;Last warning!...&amp;quot;) } } But let&amp;rsquo;s say you only wanna use ONLY the warn functionality of log namespace from fmt module:</description>
      </item>
      
      <item>
        <title>Behaviour</title>
        <link>https://follang.org/v0.11-docs/spec/behaviour/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/v0.11-docs/spec/behaviour/</guid>
        <description>Build-in functions Fol has some build-in functions offered by compiler, and you access them by . (with space/newline/bracket before):
var contPoint: ptr[int] = 10;	// make a pointer and asign the memory to value of 10 .print(.pointer_value(contPoint));	// print the dereferenced value of pointer Macro system are a very complicated system, and yet can be used as simply as in-place replacement. A lot of build-in macros exist in the language to make the code more easy to type.</description>
      </item>
      
      <item>
        <title>Scope</title>
        <link>https://follang.org/docs/400_modules/scopes/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/docs/400_modules/scopes/</guid>
        <description>Every file in a folder is part of one package, thus they share the same scope. Thus two varibles with same name at global scope cant be defined. However, this is kind of special for functions. Functions of the same name and same amount of parameters (so identical functions, not function overloading) can be defined in two different files. When called, the one on the same file is used.
In case a function exists in two files and is called from thrid one, then this can be resolved in two ways.</description>
      </item>
      
      <item>
        <title>Control</title>
        <link>https://follang.org/docs/200_expressions/200_sta/control/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/docs/200_expressions/200_sta/control/</guid>
        <description>At least two linguistic mechanisms are necessary to make the computations in programs flexible and powerful: some means of selecting among alternative control flow paths (of statement execution) and some means of causing the repeated execution of statements or sequences of statements. Statements that provide these kinds of capabilities are called control statements. A control structure is a control statement and the collection of statements whose execution it controls. This set of statements is in turn generally structured as a block, which in addition to grouping, also defines a lexical scope.</description>
      </item>
      
      <item>
        <title>Control</title>
        <link>https://follang.org/v0.11-docs/spec/control/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/v0.11-docs/spec/control/</guid>
        <description>Statements and expressions </description>
      </item>
      
      <item>
        <title>Types</title>
        <link>https://follang.org/v0.11-docs/spec/types/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/v0.11-docs/spec/types/</guid>
        <description>Every value in Fol is of a certain data type, which tells Fol what kind of data is being specified so it knows how to work with that data. There are four main subsets: simple, container, complex and special.
Simple Simple types are the most primitive type of data:
int[options], flt[options], chr[options], bol Intiger type An integer is a number without a fractional component. We used one integer of the u32 type, the type declaration indicates that the value itâ€™s associated with should be an unsigned integer (signed integer types start with i, instead of u) that takes up 32 bits of space:</description>
      </item>
      
      <item>
        <title>Operators</title>
        <link>https://follang.org/v0.11-docs/spec/operators/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/v0.11-docs/spec/operators/</guid>
        <description></description>
      </item>
      
      <item>
        <title>Blocks</title>
        <link>https://follang.org/docs/400_modules/blocks/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/docs/400_modules/blocks/</guid>
        <description>Namespaces A namespace can be defined in three ways:
 in a subfolder same folder, but in a new file or the same file  and is done by using slash when outside the main module
def shko/other: mod[] = { pro[] main: int = { // implementation } // implementation } or in the same module file:
def shko: mod[] = { pro[] main: int = { // implementation } def shko/other: mod[] = { // implementation } } Blocks Block statement is used for scopes where members get destroyed when scope is finished.</description>
      </item>
      
      <item>
        <title>Variables</title>
        <link>https://follang.org/docs/500_items/variables/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/docs/500_items/variables/</guid>
        <description>Here are some of the ways that variables can be defined:
var[pub,mut] somename: num[i32] = 98; var[pub,exp] snotherone: str = &amp;quot;this is a string&amp;quot; var[~] yetanother = 192.56 var[+] shortlet = true var anarray: arr[str,3] = { &amp;quot;one&amp;quot;, &amp;quot;two&amp;quot;, &amp;quot;three&amp;quot; } var asequence : seq[num[i8]] = { 20, 25, 45, 68, 73,98 } var multiholder: set[num, str] = { 12, &amp;quot;word&amp;quot; } var anothermulti: set[str, seq[num[f32]]] = { &amp;quot;string&amp;quot;, {5.5, 4.</description>
      </item>
      
      <item>
        <title>Variables</title>
        <link>https://follang.org/v0.11-docs/spec/variables/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/v0.11-docs/spec/variables/</guid>
        <description>Here are some of the ways that variables can be defined:
var[pub,mut] somename: num[i32] = 98; var[pub,exp] snotherone: str = &amp;quot;this is a string&amp;quot; var[~] yetanother = 192.56 var[+] shortlet = true var anarray: arr[str,3] = { &amp;quot;one&amp;quot;, &amp;quot;two&amp;quot;, &amp;quot;three&amp;quot; } var asequence : seq[num[i8]] = { 20, 25, 45, 68, 73,98 } var multiholder: set[num, str] = { 12, &amp;quot;word&amp;quot; } var anothermulti: set[str, seq[num[f32]]] = { &amp;quot;string&amp;quot;, {5.5, 4.</description>
      </item>
      
      <item>
        <title>Ownership</title>
        <link>https://follang.org/docs/600_memory/pointers/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/docs/600_memory/pointers/</guid>
        <description>Stack vs Heap The Stack What is the stack? It&amp;rsquo;s a special region of your computer&amp;rsquo;s memory that stores temporary variables created by each function (including the main() function). The stack is a &amp;ldquo;LIFO&amp;rdquo; (last in, first out) data structure, that is managed and optimized by the CPU quite closely. Every time a function declares a new variable, it is &amp;ldquo;pushed&amp;rdquo; onto the stack. Then every time a function exits, all of the variables pushed onto the stack by that function, are freed (that is to say, they are deleted).</description>
      </item>
      
      <item>
        <title>Ownership</title>
        <link>https://follang.org/v0.11-docs/spec/pointers/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/v0.11-docs/spec/pointers/</guid>
        <description>Stack vs Heap The Stack What is the stack? It&amp;rsquo;s a special region of your computer&amp;rsquo;s memory that stores temporary variables created by each function (including the main() function). The stack is a &amp;ldquo;LIFO&amp;rdquo; (last in, first out) data structure, that is managed and optimized by the CPU quite closely. Every time a function declares a new variable, it is &amp;ldquo;pushed&amp;rdquo; onto the stack. Then every time a function exits, all of the variables pushed onto the stack by that function, are freed (that is to say, they are deleted).</description>
      </item>
      
      <item>
        <title>Functions</title>
        <link>https://follang.org/docs/500_items/functions/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/docs/500_items/functions/</guid>
        <description>A subprogram definition describes the interface to and the actions of the subprogram abstraction. A subprogram call is the explicit request that a specific subprogram be executed. A subprogram is said to be active if, after having been called, it has begun execution but has not yet completed that execution.A subprogram declaration consists of an identifier, zero or more argument parameters, a return value type and a block of code.</description>
      </item>
      
      <item>
        <title>Functions</title>
        <link>https://follang.org/v0.11-docs/spec/functions/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/v0.11-docs/spec/functions/</guid>
        <description>A subprogram definition describes the interface to and the actions of the subprogram abstraction. A subprogram call is the explicit request that a specific subprogram be executed. A subprogram is said to be active if, after having been called, it has begun execution but has not yet completed that execution.A subprogram declaration consists of an identifier, zero or more argument parameters, a return value type and a block of code.</description>
      </item>
      
      <item>
        <title>Errors</title>
        <link>https://follang.org/docs/550_sugar/errors/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/docs/550_sugar/errors/</guid>
        <description>Unlike other programming languages, FOL does not have exceptions (Rust neither). It has only two types of errors:
 braking errors recoverable errors  Breaking errors cause a program to fail abruptly. A program cannot revert to its normal state if an unrecoverable error occurs. It cannot retry the failed operation or undo the error. An example of an unrecoverable error is trying to access a location beyond the end of an array.</description>
      </item>
      
      <item>
        <title>Errors</title>
        <link>https://follang.org/v0.11-docs/spec/errors/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/v0.11-docs/spec/errors/</guid>
        <description>Unlike other programming languages, FOL does not have exceptions (Rust neither). It has only two types of errors:
 braking errors recoverable errors  Breaking errors cause a program to fail abruptly. A program cannot revert to its normal state if an unrecoverable error occurs. It cannot retry the failed operation or undo the error. An example of an unrecoverable error is trying to access a location beyond the end of an array.</description>
      </item>
      
      <item>
        <title>Pipes</title>
        <link>https://follang.org/docs/550_sugar/pipes/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/docs/550_sugar/pipes/</guid>
        <description>Piping is a process that connects the output of the expression to the left to the input of the expression of the right. You can think of it as a dedicated program that takes care of copying everything that one expressionm prints, and feeding it to the next expression. The idea is the same as bash pipes. For example, an subprogram output is piped to a conditional through pipe symbol | then the conditional takes the input and returns true or false.</description>
      </item>
      
      <item>
        <title>Pipes</title>
        <link>https://follang.org/v0.11-docs/spec/pipes/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/v0.11-docs/spec/pipes/</guid>
        <description>Piping is a process that connects the output of the expression to the left to the input of the expression of the right. You can think of it as a dedicated program that takes care of copying everything that one expressionm prints, and feeding it to the next expression. The idea is the same as bash pipes. For example, an subprogram output is piped to a conditional through pipe symbol | then the conditional takes the input and returns true or false.</description>
      </item>
      
      <item>
        <title>Concurrency</title>
        <link>https://follang.org/docs/700_processor/concurrency/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/docs/700_processor/concurrency/</guid>
        <description>Concurrency Concurrency is the ability of different tasks of a program to be executed out-of-order or in partial order, without affecting the final outcome. This allows for parallel execution of the concurrent tasks, which can significantly improve overall speed of the execution in multi-processor and multi-core systems. In more technical terms, concurrency refers to the decomposability property of a program into order-independent or partially-ordered tasks.
There are two distinct categories of concurrent task control.</description>
      </item>
      
      <item>
        <title>Concurrency</title>
        <link>https://follang.org/v0.11-docs/spec/concurrency/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/v0.11-docs/spec/concurrency/</guid>
        <description>Concurrency is the ability of different tasks of a program to be executed out-of-order or in partial order, without affecting the final outcome. This allows for parallel execution of the concurrent tasks, which can significantly improve overall speed of the execution in multi-processor and multi-core systems. In more technical terms, concurrency refers to the decomposability property of a program into order-independent or partially-ordered tasks.
There are two distinct categories of concurrent task control.</description>
      </item>
      
      <item>
        <title>Constructs</title>
        <link>https://follang.org/docs/500_items/constructs/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/docs/500_items/constructs/</guid>
        <description>Constructs are the way to declare new type of data. A construct binds an identifier, the type name, to a type.
There re two ways to declare new constructs:
 alias declarations and type definitions  Alias declaration An alias declaration binds an identifier to the given type. All the properties of the type are bound to the alias too: credit to golang:
typ[pub] I5: arr[int, 5]; So now the in the code, instead of writing arr[int, 5] we could use I5:</description>
      </item>
      
      <item>
        <title>Objects</title>
        <link>https://follang.org/v0.11-docs/spec/objects/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/v0.11-docs/spec/objects/</guid>
        <description>A type declaration binds an identifier, the type name, to a type. Type declarations come in two forms:
 alias declarations and type definitions (objects): records, enums, units and classes.  Alias declaration An alias declaration binds an identifier to the given type. All the properties of the type are bound to the alias too: credit to golang:
typ[pub] I5: arr[int, 5]; So now the in the code, instead of writing arr[int, 5] we could use I5:</description>
      </item>
      
      <item>
        <title>Generics</title>
        <link>https://follang.org/docs/500_items/generics/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/docs/500_items/generics/</guid>
        <description>Generic functions - lifting The generic programming process focuses on finding commonality among similar implementations of the same algorithm, then providing suitable abstractions so that a single, generic algorithm can cover many concrete implementations. This process, called lifting, is repeated until the generic algorithm has reached a suitable level of abstraction, where it provides maximal reusability while still yielding efficient, concrete implementations. The abstractions themselves are expressed as requirements on the parameters to the generic algorithm.</description>
      </item>
      
      <item>
        <title>Generics</title>
        <link>https://follang.org/v0.11-docs/spec/generics/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/v0.11-docs/spec/generics/</guid>
        <description>Generics allow us to write a class or method that can work with any data types. Here there is a method that returns the bigger number of two.
pro max(T: gen)(a, b: T): T { result = a | a &amp;lt; b | b; }; fun biggerFloat(a, b: flt[32]) flt[32] { return max(flt[32])(a, b); }; fun biggerInteger(a, b: int[64]) int[64] { return max(int[64])(a, b); }; And here is an object defined with generics.</description>
      </item>
      
      <item>
        <title>Blocks</title>
        <link>https://follang.org/docs/200_expressions/blocks/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/docs/200_expressions/blocks/</guid>
        <description>Statements The actions that a program takes are expressed in statements. Common actions include declaring variables, assigning values, calling subprograms, looping through collections, and branching to one or another block of code, depending on a given condition. The order in which statements are executed in a program is called the flow of control or flow of execution. The flow of control may vary every time that a program is run, depending on how the program reacts to input that it receives at run time.</description>
      </item>
      
      <item>
        <title>Build-In</title>
        <link>https://follang.org/docs/300_macros/buildin/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/docs/300_macros/buildin/</guid>
        <description>WITH BUILD-INS, ALTERNATIVES, MACROS, DEFAULTS AND TEMPLATES, YOU CAN COMPLETELY MAKE A NEW TYPESYSTEM, WITH ITS OWN KEYWORDS, IDENTIFIERS, AND BEHAVIOUR.
 IT IS NOT SUGGESTED TO RELAY HEAVILY ON MACROS BECAUSE THE CODE MIGHT LOOSES THE READABILITY WHEN SOMEONE TRIES TO USE YOUR CODE.
 Fol has many build-in functions and macros offered by compiler, and you access them by . (with space/newline/bracket before):
var contPoint: ptr[int] = 10;	// make a pointer and asign the memory to value of 10 .</description>
      </item>
      
      <item>
        <title>Keywords</title>
        <link>https://follang.org/docs/100_lexical/keywords/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/docs/100_lexical/keywords/</guid>
        <description>Fol has a number of restricted groups of keywords:
BK (build-in keywords) BK_AS as
BK_IN in
BK_IS is
BK_DO do
BK_GO go
BK_OR or
BK_AND and
BK_IF if
BK_ELSE else
BK_FOR for
BK_CASE case
BK_LIKE like
BK_TYPE type
BK_LOOP loop
BK_NONE none
BK_THIS this
BK_SELF self
BK_BREAK break
BK_RETURN return
BK_YEILD yeild
BK_PANIC panic
BK_REPORT report
BK_CHECK check
BK_ASSERT assert
BK_TRUE true
BK_FALSE false
 BUILD-IN KEYWORDS - BK:
(BK_AS|BK_IN|...)</description>
      </item>
      
      <item>
        <title>Simple</title>
        <link>https://follang.org/docs/450_type/simple/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/docs/450_type/simple/</guid>
        <description>Simple types are the most primitive type of data:
int[options], flt[options], chr[options], bol Intiger type An integer is a number without a fractional component. We used one integer of the u32 type, the type declaration indicates that the value itâ€™s associated with should be an unsigned integer (signed integer types start with i, instead of u) that takes up 32 bits of space:
var aVar: int[u32] = 45; Each variant can be either signed or unsigned and has an explicit size.</description>
      </item>
      
      <item>
        <title>Calculations</title>
        <link>https://follang.org/docs/200_expressions/300_exp/arithmetics/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/docs/200_expressions/300_exp/arithmetics/</guid>
        <description>In fol, every calcultaion, needs to be enclosed in rounded brackets ( //to evaluate ) - except in one line evaluating, the curly brackets are allowed too { // to evaluate }:
fun adder(a, b: int): int = { retun a + b // this will throw an error } fun adder(a, b: int): int = { retun (a + b) // this is the right way to enclose } Order of evaluation is strictly left-to-right, inside-out as it is typical for most others imperative programming languages:</description>
      </item>
      
      <item>
        <title>Container</title>
        <link>https://follang.org/docs/450_type/container/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/docs/450_type/container/</guid>
        <description>Containers are of compound types. They contain other primitive or constructed types. To access the types in container those brackets are used: [], so:
var container: type = { element, element, element } // declaring a container var varable: type = container[2] // accessing the last element Containers are always zero indexed
 Static Arrays Arrays arr[type,size] Arrays are the most simple type of container. They contain homogeneous type, meaning that each element in the array has the same type.</description>
      </item>
      
      <item>
        <title>Identifiers</title>
        <link>https://follang.org/docs/100_lexical/identify/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/docs/100_lexical/identify/</guid>
        <description>Encoding Identifiers in FOL can be any string of letters, digits and underscores, but beginning with a letter. Two immediate following underscores __ are not allowed.
IDENTIFIER:
[a-z A-Z] [a-z A-Z 0-9 _]* | _ [a-z A-Z 0-9 _]+
 An identifier is any nonempty ASCII string of the following form:
Either
 The first character is a letter. The remaining characters are alphanumeric or _.  Or
 The first character is _.</description>
      </item>
      
      <item>
        <title>Macors</title>
        <link>https://follang.org/docs/300_macros/macros/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/docs/300_macros/macros/</guid>
        <description>Are a very complicated system, and yet can be used as simply as in-place replacement. A lot of build-in macros exist in the language to make the code more easy to type. Below are some system defined macros.
For example, wherever $ is before any variable name, its replaced with .to_string. Or wherever ! is before bol name, its replaced with .not but when the same ! is placed before ptr it is replaced with .</description>
      </item>
      
      <item>
        <title>Alternatives</title>
        <link>https://follang.org/docs/300_macros/alternatives/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/docs/300_macros/alternatives/</guid>
        <description>Alternatives are used when we want to simplify code. For example, define an alternative, so whenever you write +var it is the same as var[+].
def &#39;+var&#39;: alt = &#39;var[+]&#39; def &#39;~var&#39;: alt = &#39;var[~]&#39; def &#39;.pointer_content&#39;: alt = &#39;.pointer_value&#39; </description>
      </item>
      
      <item>
        <title>Defaults</title>
        <link>https://follang.org/docs/300_macros/defaults/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/docs/300_macros/defaults/</guid>
        <description>Defaults are a way to change the default behaviour of options. Example the default behaviour of str when called without options. By defalt str is it is saved on stack, it is a constant and not public, thus has str[pil,imu,nor], and we want to make it mutable and saved on heap by default:
def &#39;str&#39;: def[] = &#39;str[new,mut,nor]&#39; </description>
      </item>
      
      <item>
        <title>Comments</title>
        <link>https://follang.org/docs/100_lexical/comments/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/docs/100_lexical/comments/</guid>
        <description>Normal comments Comments in FOL code follow the general Rust/C++ style of line (//) and block (/* ... */) comment forms and are interpreted as a form of whitespace.
LINE_COMMENT :
// (~[/ !] | //) ~\n* | //
BLOCK_COMMENT :
/* (~[* !] ) ( ~*/)* */ | /**/
 Docs comments Doc comments beginning with exactly three slashes (///) are interpreted as a special syntax for doc attributes.</description>
      </item>
      
      <item>
        <title>Complex</title>
        <link>https://follang.org/docs/450_type/complex/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/docs/450_type/complex/</guid>
        <description>Strings Strings are a complex type that are made of array of chars with null terminator &amp;lsquo;\0&amp;rsquo;, and by default is utf8 encoded:
str[8,16,32] str is similar to seq[char[]]
Imaginary Imaginary numbers
img[] Optional Either are empty or have a value
opt[] Multiple mul[] Any any[] </description>
      </item>
      
      <item>
        <title>Literals</title>
        <link>https://follang.org/docs/200_expressions/300_exp/literals/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/docs/200_expressions/300_exp/literals/</guid>
        <description>A literal expression consists of one or more of the numerical/letter forms described earlier. It directly describes a numbers, characters, booleans, containers and constructs.
There are two type of literals:
 values calls  Value literals Value literals are the simpliest expressions. They are direct values assigned to variables and are divided into two types:
 singletons clusters  Singelton literals Singleton literals represent one sigle values:
4 // intiger literal 0xA8 // hex-intiger literal 4.</description>
      </item>
      
      <item>
        <title>Templates</title>
        <link>https://follang.org/docs/300_macros/temp/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/docs/300_macros/temp/</guid>
        <description>Templates are supposed to be mostly used for operator overloading. They are glorified functions, hence used with pro or fun instead of def.
For example here is how the != is defined:
fun &#39;!=&#39;(a, b: int): bol = { return .not(.eq(a, b)) } .assert( 5 != 4 ) or define $ to return the string version of an object (careful, it is object$ and not $object, the latest is a macro, not a template):</description>
      </item>
      
      <item>
        <title>Ranges</title>
        <link>https://follang.org/docs/200_expressions/300_exp/ranges/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/docs/200_expressions/300_exp/ranges/</guid>
        <description>There are two range expressions:
 Defined ranges Undefined ranges  Defined ranges Defined ranges represent a group of values that are generated as a sequence based on some predefined rules. Ranges are represented with two dots .. operator.
{ 1..8 } // a range from 1 to 8 { 1,2,3,4,5,6,7,8 } { 8..1 } // a range from 8 to 1 { 8,7,6,5,4,3,2,1 } { 1..8..2 } // a range from 1 to 8 jumping by 2 { 1,3,5,7 } { 3.</description>
      </item>
      
      <item>
        <title>Special</title>
        <link>https://follang.org/docs/450_type/special/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/docs/450_type/special/</guid>
        <description>Pointer ptr[basetype] Error err[basetype] Null / Emoty / Junk non nil jun </description>
      </item>
      
      <item>
        <title>Whitespaces</title>
        <link>https://follang.org/docs/100_lexical/whitespaces/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/docs/100_lexical/whitespaces/</guid>
        <description>Whitespace is any non-empty string containing only characters that have the below Unicode properties:
 U+0009 (horizontal tab, &amp;lsquo;\t&amp;rsquo;) U+000A (line feed, &amp;lsquo;\n&amp;rsquo;) U+000B (vertical tab) U+000C (form feed) U+000D (carriage return, &amp;lsquo;\r&amp;rsquo;) U+0020 (space, &#39; &amp;lsquo;) U+0085 (next line) U+200E (left-to-right mark) U+200F (right-to-left mark) U+2028 (line separator) U+2029 (paragraph separator)  </description>
      </item>
      
      <item>
        <title>Access</title>
        <link>https://follang.org/docs/200_expressions/300_exp/access/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/docs/200_expressions/300_exp/access/</guid>
        <description>There are four access expresions:
 namespace member access subprogram member access container memeber access field member access  Subprogram access In most programming languages, it is called &amp;ldquo;method-call expresion&amp;rdquo;. A method call consists of an expression (the receiver) followed by a single dot ., an expression path segment, and a parenthesized expression-list:
&amp;quot;3.14&amp;quot;.cast(float).pow(2); // casting a numbered string to float, then rising it to power of 2 Namespaces access Accesing namespaces is done through double colon operator :::</description>
      </item>
      
      <item>
        <title>Letters</title>
        <link>https://follang.org/docs/100_lexical/strings/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/docs/100_lexical/strings/</guid>
        <description>Characters A character is a single Unicode element enclosed within quotes U+0022 (&amp;quot;) with the exception of U+0022 itself, which must be escaped by a preceding U+005C character (\).
var aCharacter: chr = &amp;quot;z\n&amp;quot; var anotherOne: str = &amp;quot;èªž\n&amp;quot; Raw characters Raw character literals do not process any escapes. They are enclosed within single-quotes U+0027 (&#39;) with the exception of U+0027 itself:
var aCharacter: chr = &#39;z&#39; Strings A string is a single or a sequence of Unicode elements enclosed within quotes U+0022 (&amp;quot;) with the exception of U+0022 itself, which must be escaped by a preceding U+005C character (\).</description>
      </item>
      
      <item>
        <title>Numbers</title>
        <link>https://follang.org/docs/100_lexical/numbers/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/docs/100_lexical/numbers/</guid>
        <description>A number is either an integer, floating-point or imaginary. The grammar for recognizing the kind of number is mixed.
Intigers An integer has one of four forms:
 A decimal literal starts with a decimal digit and continues with any mixture of decimal digits and underscores. A hex literal starts with the character sequence U+0030 U+0078 (0x) and continues as any mixture (with at least one digit) of hex digits and underscores.</description>
      </item>
      
      <item>
        <title>Symbols</title>
        <link>https://follang.org/docs/100_lexical/symbols/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/docs/100_lexical/symbols/</guid>
        <description>Operators Fol allows user defined operators. An operator is any combination of the following characters:
= + - * / &amp;gt; . @ $ ~ &amp;amp; % &amp;lt; : ! ? ^ # ` \ _ The grammar uses the terminal OP to refer to operator symbols as defined here.
Brackets Bracket punctuation is used in various parts of the grammar. An open bracket must always be paired with a close bracket.</description>
      </item>
      
      <item>
        <title>Markdown Syntax Guide</title>
        <link>https://follang.org/blog/markdown-syntax/</link>
        <pubDate>Mon, 11 Mar 2019 00:00:00 +0000</pubDate>
        
        <guid>https://follang.org/blog/markdown-syntax/</guid>
        <description>&lt;p&gt;Lorem est tota propiore conpellat pectoribus de&lt;br /&gt;
pectora summo. Redit teque digerit hominumque toris verebor lumina non cervice&lt;br /&gt;
subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc&lt;br /&gt;
caluere tempus&lt;/p&gt;</description>
      </item>
      
    
  </channel>
</rss>